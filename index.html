<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DSA Web Project</title>
  <link rel="stylesheet" href="index.css">
</head>

<body>

  <header>
    <nav>
      <div class="logo">Huda Code</div>
      <ul>
        <li><a href="#array">Array</a></li>
        <li><a href="#String">String</a></li>
        <li><a href="#stack">Stack</a></li>
        <li><a href="#LL">LinkedList</a></li>
        <li><a href="#sorting">Sorting</a></li>
        <li><a href="#Searching">Searching</a></li>
        <li><a href="#Queue">Queue</a></li>
        <li><a href="#Grap">Graph</a></li>
        <li><a href="#tree">Trees</a></li>
        <li><a href="#binaryTree">Binary Tress</a></li>
        <li><a href="#Dp">Dynamic Programming</a></li>
      </ul>

    </nav>
  </header>

  <!-- idhr mujhe apne bare mai linkna hai (use display:flex) -->
  <div class="hero">
    <div class="img"><img src="faham1.jpeg" alt=""></div>
    <div class="aboutme">
      <h2>(About me)</h2>
      <p> Hello Everyone. Today, I'm excited to delve into the fascinating world of Data Structures and Algorithms,
        often
        referred to as DSA. In this presentation,
        we will explore the fundamental concepts that serve as the backbone of computer science and software
        development.

        Data Structures and Algorithms are the building blocks of efficient and powerful software.
        They enable us to store, retrieve, and manipulate data, providing solutions to a wide range
        of real-world problems. Whether you're a computer science enthusiast, a coding beginner,
        or simply curious about how the digital world works, understanding DSA is essential.

        In the next few minutes, we'll demystify what DSA is all about, why it's crucial,
        and how it impacts the performance of the software applications we use daily.
        We'll also touch on some common DSA topics and discuss their significance.

        So, let's embark on this journey of discovery and unravel the beauty
        and importance of Data Structures and Algorithms.
        Whether you're a seasoned programmer or just beginning your coding adventure,
        this presentation will help you gain a deeper appreciation for the magic that
        happens behind the scenes in the world of software development. </p>
    </div>
  </div>

  <section id="array">
    <h1>Arrays</h1>
    <div class="question">
      <div class="solve">
        <h2>Ques 1.Enter the value of array from user and print them.</h2>
        <pre>

          int main() {
          int arr[5];
          for(int i = 0;i < 5;i++){
              printf(" Enter the value : ");
              scanf("%d",&arr[i]);
          }
          for(int j =0;j < 5;j++){
              printf("Yours values are : ");
              printf("%d \n",arr[j]);
          }
          
              return 0;
          }
      </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
Enter the value : 1 2 3 4 5
Yours values are : 1 2 3 4 5 
        </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 2.print array in reverse order</h2>
        <pre>

          int main() {
            int n;
            printf("Enter the size of an array : ");
            scanf("%d",&n);
            int arr[n];
            for(int i = 0;i < n;i++){
                printf("Enter the value : ");
                scanf("%d",&arr[i]);
            }
            printf("array in reverse order : ");
            for(int j = n-1;j>=0;j--){
                printf("%d ",arr[j], " ");
            }
          
              return 0;
          }
      </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
          Enter the size of an array : 5
          Enter the value : 1 2 3 4 5
          array in reverse order : 5 4 3 2 1 
        </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 3. Copy array into another array..</h2>
        <pre>

         int main(){
            int n;
                printf("Enter the size of array : ");
                scanf("%d",&n);
                int arr1[n],arr2[n],i;
                
                printf("Enter array elemnts : ");
                for(i = 0;i < n;i++){
                    scanf("%d",&arr1[i]);
                }
            
                 for(i = 0;i < n;i++){
                    arr2[i] = arr1[i];
                }
                printf("Second array elements :\n ");
                 for(i = 0;i < n;i++){
                    printf("%d \n",arr2[i]);
                }
            
                return 0;
            }
      </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
  Enter the size of array : 5
  Enter array elemnts : 10 20 30 40 50
  Second array elements :
  10 	20 	30 	40 	50 	
        </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 4. Print the copied array into another array and print in revrse order.</h2>
        <pre>

          int main() {
            int n;
            printf("Enter the size of array : ");
            scanf("%d",&n);
            int arr1[n],arr2[n],i;
        
            for(i = 0;i < n;i++){
                printf("Enter array elemnts : ");
                scanf("%d",&arr1[i]);
            }
        
             for(i = 0;i < n;i++){
                arr2[i] = arr1[i];
            }
            printf("Second array elements :\n ");
             for(i = n -1 ;i >= 0;i--){
                printf("%d \t",arr2[i]);
            }
        
            return 0;
        }
         
      </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
Enter the size of array : 5
Enter array elemnts : 10 20 30 4 0
Second array elements :
 0 	4 	30 	20 	10 	
        </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 5.Enter an array from user and print only enen number. </h2>
        <pre>

          int main() {
            int n;
            printf("Enter the size of array : ");
            scanf("%d",&n);
        
            int arr[n],i;
            printf("Enter array elemnts : ");
            for(i = 0;i < n;i++){
                scanf( " %d " , &arr[i] );
            }
       
            for(i = 0; i < n ;i++){
                if( arr[i] % 2 == 0 ){
                    printf( " Even values present in the array : %d \n " , arr[i]);
                }
            }
            return 0;
          }
         
      </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
 Enter the size of array : 5
 Enter array elemnts : 10 14 15 6 2
 Even values present in the array : 10 
 Even values present in the array : 14 
 Even values present in the array : 6 
 Even values present in the array : 2 
          
        </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 6. Print all the positive values.</h2>
        <pre>

        int main(){
        int n;
        printf("Enter the size of array : ");
        scanf("%d",&n);
    
        int arr[n],i;

        printf( " Enter array elemnts : " );
        for(i = 0;i < n;i++){
            scanf("%d",&arr[i]);
        }
        //print if num is positive
        for(i = 0;i < n;i++){
            if(arr[i] > 0){
                printf("Positive values present in the array : %d \n",arr[i]);
            }
        }
        return 0;
        }
      </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
Enter the size of array : 5
Enter array elemnts : 1 -2 -3 -7 5
Positive values present in the array : 1 
Positive values present in the array : 5 
          
        </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 7.Print the array elements after calculating the square.</h2>
        <pre>

          int main() {
            int n;
            printf("Enter the size of array : ");
            scanf("%d",&n);
        
            int arr[n],i;
            printf("Enter array elemnts : ");
            for(i = 0;i < n;i++){
                scanf("%d",&arr[i]);
            }
            for(i = 0;i < n;i++){
                    printf("Square of array value : %d \n",arr[i] * arr[i]);
             }
                return 0;
            }
        
         
      </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
Enter the size of array : 5
Enter array elemnts : 1 2 3 4 5
Square of array value : 1 
Square of array value : 4 
Square of array value : 9 
Square of array value : 16 
Square of array value : 25 
        </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 8. Find the minimum in the array.</h2>
        <pre>
          int main(){
                int n;
                printf("Enter the size of array : ");
                scanf("%d",&n);
            
                int arr[n],i;
                
                printf("Enter array elemnts : ");
                for(i = 0;i < n;i++){
                    scanf( " %d " , &arr[i]);
                }
                int minimum = arr[0];
                for(i = 0;i < n;i++){
                    if(arr[i] < minimum) minimum = arr[i];
                }
                printf(" minimum value present in the array %d ", minimum);
                return 0;
                    return 0;
                    }
         
      </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
Enter the size of array : 5
Enter array elemnts : 1 441 52 4 85 
minimum value present in the array 1 
        </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 8.Find the maximum number in the array.</h2>
        <pre>

          int main() {
        
            int n;
            printf("Enter the size of array : ");
            scanf("%d",&n);
        
            int arr[n],i;
            
            printf("Enter array elemnts : ");
            for(i = 0;i < n;i++){
                scanf("%d",&arr[i]);
            }
            int maximum = arr[0];
            for(i = 0;i < n;i++){
                if(arr[i]>maximum) maximum = arr[i];
            }
            printf("maximum value present in the array %d ",maximum);
            return 0;
        }

         
      </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>

 Enter the size of array : 5
 Enter array elemnts : 1 14 15 45 2
 maximum value present in the array 45 
        </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 9. Print the kth smallest element.</h2>
        <pre>

          void bubblesort(int arr[],int n){
            for(int i = 0;i < n-1;i++){
                    for(int j = 0;j < n-1-i;i++){
                        if(arr[j] > arr[j+1]){
                            int temp = arr[j];
                            arr[j] = arr[j+1];
                            arr[j+1] = temp;
                        }
                    }
                }
            }

            int kthfindSmall(int arr[],int k,int size){
                int count = 1,val = arr[0];
                for(int i = 1;i <  size;i++){
                    if(arr[i]>val){
                        val = arr[i];
                        count++;
                    }
                    if(count == k) return val;
                }
            }
            
            
            int main() {
                int n,k;
                printf("Enter the size of array : ");
                scanf("%d",&n);
            
                int arr[n],i;
                
                printf("Enter array elemnts : ");
                for(i = 0;i < n;i++){
                    scanf("%d",&arr[i]);
                }
                
                bubblesort(arr,n);
                printf("Enter the kth element ");
                scanf("%d",&k);
                int result = kthfindSmall(arr,k,n);
                printf("The kth smallest element is : %d ",result);
              
                return 0;   
            }
        
      </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
Enter the size of array : 10
Enter array elemnts : 1 2 2 2 3 3 4 9 4 5
Enter the kth element 4
The kth smallest element is : 4 
        </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 10. Print the sum of all elements present in the array.</h2>
        <pre>

        int main() {
      
         int n;
            int sum = 0;
            printf("Enter the size of array : ");
            scanf("%d",&n);
        
            int arr[n],i;
            
            printf("Enter array elemnts : ");
            for(i = 0;i < n;i++){
                scanf("%d",&arr[i]);
            }
        
            for(i = 0;i < n;i++){
             sum = sum + arr[i];
            }
            printf("sum of all elements present in the array : %d ",sum);
            return 0;   
        } 
      </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
Enter the size of array : 5
Enter array elemnts : 1 2 3 4 5
sum of all elements present in the array : 15
        </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 11.Enter an array from user and find the duplicate values?</h2>
        <pre>

          int main(){
            int n;
                printf("Enter the size of array : ");
                scanf("%d",&n);
            
                int arr[n],i;
                
                printf("Enter array elemnts : ");
                for(i = 0;i < n;i++){
                    scanf("%d",&arr[i]);
                }
            
                for(int i = 0; i < n; i++) {
                for(int j = i + 1; j < n; j++) {
                if(arr[i] == arr[j]){
                printf(" duplicate element present in the array : %d \n", arr[j]);
                    }
                }
              } 
              return 0;
              } 
      </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
Enter the size of array : 5
Enter array elemnts : 1 2 1 3 5
duplicate element present in the array : 1 
        </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 12.Enter an array from user and remove the duplicate values and fill with zero?</h2>
        <pre>

          int main(){
            int arr[20], i, j, k, size;
            
             printf (" Define the number of elements in an array: ");
             scanf (" %d", &size);
            
             printf (" \n Enter %d elements of an array: \n ", size);
             for ( i = 0; i < size; i++){
                 scanf (" %d", &arr[i]);
             }
            
             for ( i = 0; i < size; i ++){
                 for ( j = i + 1; j < size; j++){
                     if ( arr[i] == arr[j]){
                         for ( k = j; k < size - 1; k++){
                           arr[k] = arr [k + 1];
                         }
                         size--;
                         j--;
             }}}
             printf (" \n Array elements after deletion of the duplicate elements: ");
             for ( i = 0; i < size; i++){
             printf ("%d \n", arr[i]);
             }
             return 0;
            }
         
         
      </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
Define the number of elements in an array: 10
Enter 10 elements of an array: 
1 2 2 2 2 3 4 5 5 5
Array elements after deletion of the duplicate elements: 1 	2 	3 	4 	5 		
        </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 13. Count the duplicate? </h2>
        <pre>

          int main(){
            int arr[20], i, j, k, size,count = 0;
            
             printf (" Define the number of elements in an array: ");
             scanf (" %d", &size);
            
             printf (" \n Enter %d elements of an array: \n ", size);
             for ( i = 0; i < size; i++){
                 scanf (" %d", &arr[i]);
             }
            
             for ( i = 0; i < size; i ++){
                 for ( j = i + 1; j < size; j++){
                     if ( arr[i] == arr[j]){
                         count++;
                         for ( k = j; k < size - 1; k++){
                           arr[k] = arr [k + 1];
                         }
                         size--;
                         j--;
             }}}
             printf (" \n Array elements after deletion of the duplicate elements: ");
             for ( i = 0; i < size; i++){
             printf ("%d \t", arr[i]);
             }
             printf("\n Total duplicate : %d ",count);
             return 0;
            }
         
      </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
Define the number of elements in an array: 7
Enter 7 elements of an array: 
1 1 4 4 2 3 5
Array elements after deletion of the duplicate elements: 1 	4 	2 	3 	5 	
Total duplicate : 2 
        </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 14.Enter an array from user and print all possible combinations of the elements?</h2>
        <pre>

          int main() {
          int arr[20], i, j, k, size;
        
         printf ("Enter the size of an array: ");
         scanf (" %d", &size);
        
         printf (" \n Enter %d elements of an array: \n ", size);
         for ( i = 0; i < size; i++){
             scanf (" %d", &arr[i]);
         }
        
         for ( i = 0; i < size; i ++){
             for ( j = i; j < size; j++){
                 for( k = i;k <= j;k++){
        
                     printf("%d \t ",arr[k]);
                 }
                 printf("\n");
         }
             printf("\n");
         }
        
            return 0;
        }
         
      </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
          Enter the size of an array: 5
          Enter 5 elements of an array: 1 2 3 4 5

          1 	
          1 	2 	
          1 	2 	3 	
          1 	2 	3 	4 	
          1 	2 	3 	4 	5 	
          
          2 	
          2 	3 	
          2 	3 	4 	
          2 	3 	4 	5 	
          
          3 	
          3 	4 	
          3 	4 	5 	
          
          4 	
          4 	5 

          5 	
          
          
        </pre>
      </div>
    </div>

    <div class="question">
      <div class="solve">
        <h2>Ques 15. compare two arrays are same or not.</h2>
        <pre>

          #include<stdio.h>

            int main(){
                int i,j,n1,n2,count = 0;
                int arr[n1],arr1[n2];
            
                printf("Enter the size of an array : ");
                scanf("%d",&n1);
                
                printf("Enter the size of an array : ");
                scanf("%d",&n2);
                
                if(n1 == n2){
                printf("Enter the elements of first array : \n");
                for( i = 0;i < n1 ;i++) scanf(" %d \n", &arr[i] );
                
                printf("Enter elements of second array : \n ");
                for( i = 0;i < n2 ;i++) scanf(" %d \n", &arr1[i] );
                }
                else printf(" Bec size is not same \n");  
                
                
                  if(n1 == n2){
                  for(i = 0;i < n1;i++){
                    for(j = 0;j < n2;j++){
                        if(arr[i] == arr1[j]){
                        count++;
                        break;
                    } } }
                  }
                    if((count == n1) && (count == n2)){
                        printf("Arrays are same : ");
                    }
                    else{
                        printf("Arrays are not same : ");
                    }
                  
                return 0;
            }
         
      </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
          Enter the size of an array : 2
          Enter the size of an array : 2
          Enter the elements of first array : 
          1
          2

          Enter elements of second array : 
          1
          2
           Arrays are same : 

                 or 

          Enter the size of an array : 5
          Enter the size of an array : 7
          Bec size is not same 
          Arrays are not same 
        </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 16.Merge the two sorted arrays into one array but in sorted order </h2>
        <pre>


int main() {

  int n1,n2,i,n3;//declare
  
  printf("Enter the size of an array : ");//first arr size input
  scanf("%d",&n1);
  printf("Enter the size of an array : ");//second arr size input
  scanf("%d",&n2);
  
  n3 = n1+n2;
  int arr1[n1],arr2[n2],arrFinal[n3];
  
  printf("Enter the elements : \n ");
  for( i = 0;i < n1 ;i++){
      scanf(" %d ", &arr1[i]);
  }
  
  printf("Enter the elements : \n ");
  for(int i = 0;i < n2;i++){
      scanf("%d",&arr2[i]);
  }
  
  for(int i = 0; i < n1; i++){
      arrFinal[i] = arr1[i];
  }
  for(int i = 0; i < n2; i++) {
      arrFinal[i + n1] = arr2[i];
  }
   printf("The merged array: \n ");
      for( i = 0; i < n3; i++){
      printf("%d \t ", arrFinal[i]);
  }
  printf("\n");
  
  for(i = 0;i < n3;i++){
  for(int j =i+1;j < n3;j++){
      if(arrFinal[i] > arrFinal[j]){
          int temp = arrFinal[i];
          arrFinal[i] = arrFinal[j];
          arrFinal[j] = temp;
      }
    }
  }
  printf("The merge sorted array is : \n");
  for(i = 0;i < n3;i++){
      printf("%d \t",arrFinal[i]);
  }
  return 0;
  }
         
      </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
          Enter the size of an array : 5
          Enter the size of an array : 5
          Enter the elements : 
           1 4 5 7 8
           Enter the elements : 
           2 3 6 9 10
           The merged array: 
          1 	 4 	 5 	 7 	 8 	 2 	 3 	 6 	 9 	 10 	 
          The merge sorted array is : 
          1 	2 	3 	4 	5 	6 	7 	8 	9 	10 		
        </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 17.Check array is pallindrome or not </h2>
        <pre>
            int main() {
            
            int size,i,count = 0;
            
            printf("Enter the size of an array : ");
            scanf("%d",&size);
            int arr[size];
            
            printf("Enter the elements : \n ");
            for( i = 0;i < size;i++){
                scanf(" %d ", &arr[i]);
            }
            int start = arr[0];
            int end = arr[size-1];
            
            while(start < = end){
                if(start == end){
                    count++;
                }else{
                    printf(" Array is not pallindrome");
                    break;
                }
                start++;
                end--;
            }
                if(count == size){
                    printf("Array is pallindrome ");
                }
            
            return 0;
            }
         
      </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
          Enter the size of an array : 5
          Enter the elements : 
           1 2 3 4 5
           Array is not pallindrome
        </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 18.find the minima in the function </h2>
        <pre>

          int minima(int arr[],int n){
            for(int i = 1;i < n-1;i++){
                if(arr[i] < arr[i-1] && arr[i] < arr[i+1]){
                    return i;
                }
            }
            return -1;
           }
           int main() {
           int arr[6] = {5,4,6,7,6,9};
           int ans = minima(arr,6);
           if(ans >= 0){
               printf("found at index %d ",ans);
           }
           else{
               printf("Not found");
           }
           
               return 0;
           }
         
      </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
fount at index 1
        </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2> Ques 19.find the maxima of the function </h2>
        <pre>

          int maxima(int arr[],int n){
           for(int i = 1;i < n-1;i++){
               if(arr[i] > arr[i-1] && arr[i] > arr[i+1]){
                   return i;
               }
           }
           return -1;
          }
          int main() {
          int arr[6] = {5,4,6,7,6,9};
          int ans = maxima(arr,6);
          if(ans >= 0){
              printf("found at index %d ",ans);
          }
          else{
              printf("Not found");
          }
          
              return 0;
          }
      </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
        found at index 3
        </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 20.Trapping rain water </h2>
        <pre>

          void leftmax(int arr[], int size, int leftarr[])
          {
              leftarr[0] = arr[0];
              int max = arr[0];
              for (int i = 1; i < size; i++)
              {
                  if (arr[i] > max)
                  {
                      max = arr[i];
                  }
                  leftarr[i] = max;
              }
          }
          void rytmax(int arr[], int size, int rytarr[])
          {
              rytarr[size - 1] = arr[size - 1];
              int max = arr[size - 1];
              for (int i = size - 2; i >= 0; i--)
              {
                  if (arr[i] > max)
                  {
                      max = arr[i];
                  }
                  rytarr[i] = max;
              }
          }
          int CaltrapWater(int arr[], int size, int leftmax[], int rightmax[], int width)
          {
              int sum = 0;
              for (int i = 0; i < size; i++)
              {
                  int trappedwater = (meraMin(leftmax[i], rightmax[i]) - arr[i]) * width;
                  sum = sum + trappedwater;
              }
              return sum;
          }
          
          int meraMin(int a, int b)
          {
              if (a < b)
                  return a;
              return b;
          }
          
          int main()
          {
              int width = 1;
              int arr[7] = {4, 2, 0, 6, 3, 2, 5};
              int leftarr[7], rytarr[7];
          
              leftmax(arr, 7, leftarr);
              rytmax(arr, 7, rytarr);
          
              int result = CaltrapWater(arr, 7, leftarr, rytarr, width);
              printf("The total water which is trapped %d ", result);
          
              return 0;
          }
          
         
      </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
          The total water which is trapped 11 
        </pre>
      </div>
    </div>



    </div>

    </div>

    </div>

    </div>

    </div>
  </section>
  <!---------------------------------------2darray------------------------------------------->
  <section id="array">
    <h1>2D Array</h1>
    <div class="question">
      <div class="solve">
        <h2>Ques 11.SUM OF MATRIX </h2>
        <pre>

        int main(){
            int arr1[20][20], arr2[20][20], sum[20][20];
            int i = 0, j = 0, row, col;
        
            printf("Enter how many rows u want : ");
            scanf("%d", &row);
            printf("Enter how many cols u want : ");
            scanf("%d", &col);
        
            for (i = 0; i < row; i++){
                for (j = 0; j < col; j++)
                {
                    printf("Enter the values of array arr[%d][%d] : ", i, j);
                    scanf("%d", &arr1[i][j]);
                }
            }
            printf("Enter the values of second array : \n ");
            for (i = 0; i < row; i++)
            {
                for (j = 0; j < col; j++)
                {
                    printf("Enter the values of arr[%d][%d] : ", i, j);
                    scanf("%d", &arr2[i][j]);
                }
            }
            printf("print the values of first array : \n ");
            for (i = 0; i < row; i++)
            {
                for (j = 0; j < col; j++)
                {
                    printf("%d\t", arr2[i][j], " ");
                }
                printf("\n");
            }
            printf("print the values of second array : \n ");
            for (i = 0; i < row; i++)
            {
                for (j = 0; j < col; j++)
                {
                    printf("%d\t", arr2[i][j]);
                }
                printf("\n");
            }
            // sum of both
            for (i = 0; i < row; i++)
            {
                for (j = 0; j < col; j++)
                {
                    sum[i][j] = arr1[i][j] + arr2[i][j];
                }
            }
            // printing
            printf("sum of both matrixes :\n ");
            for (i = 0; i < row; i++)
            {
                for (j = 0; j < col; j++)
                {
                    printf("%d\t", sum[i][j]);
                }
                printf("\n");
            }
            return 0;
        }
          
    </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
        Enter how many rows u want : 3
        Enter how many cols u want : 3

        Enter the values of array arr[0][0] : 1 
        Enter the values of array arr[0][1] : 2 
        Enter the values of array arr[0][2] : 3
        Enter the values of array arr[1][0] : 4 
        Enter the values of array arr[1][1] : 5 
        Enter the values of array arr[1][2] : 6 
        Enter the values of array arr[2][0] : 7 
        Enter the values of array arr[2][1] : 8 
        Enter the values of array arr[2][2] : 9 

        Enter the values of second array : 

        Enter the values of arr[0][0] : 1
        Enter the values of arr[0][1] : 2 
        Enter the values of arr[0][2] : 3 
        Enter the values of arr[1][0] : 4 
        Enter the values of arr[1][1] : 5 
        Enter the values of arr[1][2] : 6 
        Enter the values of arr[2][0] : 7 
        Enter the values of arr[2][1] : 8 
        Enter the values of arr[2][2] : 9 
        
        print the values of first array : 1 2 3 4 5 6 7 8 9 
        print the values of second array : 1 2 3 4 5 6 7 8 9 
        sum of both matrixes : 2 4 6 8 10 12 14 16 18
      </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 12.MULTIPLICATION MATRIX </h2>
        <pre>
          int main(){
            int arr1[20][20], arr2[20][20], mul[20][20];
            int i = 0, j = 0, row, col;
        
            printf("Enter how many rows u want : ");
            scanf("%d", &row);
            printf("Enter how many cols u want : ");
            scanf("%d", &col);
        
            for (i = 0; i < row; i++){
                for (j = 0; j < col; j++){
                    printf("Enter the values of array arr[%d][%d] : ", i, j);
                    scanf("%d", &arr1[i][j]);
                }
            }
            printf("Enter the values of second array : \n ");
            for (i = 0; i < row; i++){
                for (j = 0; j < col; j++){
                    printf("Enter the values of arr[%d][%d] : ", i, j);
                    scanf("%d", &arr2[i][j]);
                }
            }
            printf("print the values of first array : \n ");
            for (i = 0; i < row; i++){
                for (j = 0; j < col; j++){
                    printf("%d\t", arr2[i][j], " ");
                }
                printf("\n");
            }
            printf("print the values of second array : \n ");
            for (i = 0; i < row; i++){
                for (j = 0; j < col; j++){
                    printf("%d\t", arr2[i][j]);
                }
                printf("\n");
            }
            // mul of both
            for (i = 0; i < row; i++){
                for (j = 0; j < col; j++){
                    mul[i][j] = arr1[i][j] * arr2[i][j];
                }
            }
            // printing
            printf("multiplication of both matrixes :\n ");
            for (i = 0; i < row; i++){
                for (j = 0; j < col; j++){
                    printf("%d\t", mul[i][j]);
                }
                printf("\n");
            }
            return 0;
        }

    </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
          Enter how many rows u want : 3
          Enter how many cols u want : 3
  
          Enter the values of array arr[0][0] : 1 
          Enter the values of array arr[0][1] : 2 
          Enter the values of array arr[0][2] : 3
          Enter the values of array arr[1][0] : 4 
          Enter the values of array arr[1][1] : 5 
          Enter the values of array arr[1][2] : 6 
          Enter the values of array arr[2][0] : 7 
          Enter the values of array arr[2][1] : 8 
          Enter the values of array arr[2][2] : 9 
  
          Enter the values of second array : 
  
          Enter the values of arr[0][0] : 1
          Enter the values of arr[0][1] : 2 
          Enter the values of arr[0][2] : 3 
          Enter the values of arr[1][0] : 4 
          Enter the values of arr[1][1] : 5 
          Enter the values of arr[1][2] : 6 
          Enter the values of arr[2][0] : 7 
          Enter the values of arr[2][1] : 8 
          Enter the values of arr[2][2] : 9 
          
          print the values of first array : 1 2 3 4 5 6 7 8 9 
          print the values of second array : 1 2 3 4 5 6 7 8 9 

          multiplication of both matrixes : 1 4 9 16 25 36 49 64 81
      </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 13.Subtraction OF A MATRIX </h2>
        <pre>

    int main(){
    int arr1[20][20], arr2[20][20], sub[20][20];
    int i = 0, j = 0, row, col;

    printf("Enter how many rows u want : ");
    scanf("%d", &row);
    printf("Enter how many cols u want : ");
    scanf("%d", &col);

    for (i = 0; i < row; i++)
    {
        for (j = 0; j < col; j++)
        {
            printf("Enter the values of array arr[%d][%d] : ", i, j);
            scanf("%d", &arr1[i][j]);
        }
    }
    printf("Enter the values of second array : \n ");
    for (i = 0; i < row; i++)
    {
        for (j = 0; j < col; j++)
        {
            printf("Enter the values of arr[%d][%d] : ", i, j);
            scanf("%d", &arr2[i][j]);
        }
    }
    printf("print the values of first array : \n ");
    for (i = 0; i < row; i++)
    {
        for (j = 0; j < col; j++)
        {
            printf("%d\t", arr1[i][j], " ");
        }
        printf("\n");
    }
    printf("print the values of second array : \n ");
    for (i = 0; i < row; i++)
    {
        for (j = 0; j < col; j++)
        {
            printf("%d\t", arr2[i][j]);
        }
        printf("\n");
    }
    // mul of both
    for (i = 0; i < row; i++)
    {
        for (j = 0; j < col; j++)
        {
            sub[i][j] = arr2[i][j] - arr1[i][j];
        }
    }
    // printing
    printf("multiplication of both matrixes :\n ");
    for (i = 0; i < row; i++)
    {
        for (j = 0; j < col; j++)
        {
            printf("%d\t", sub[i][j]);
        }
        printf("\n");
    }
    return 0;
}

    </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
          Enter how many rows u want : 3
          Enter how many cols u want : 3
  
          Enter the values of array arr[0][0] : 1 
          Enter the values of array arr[0][1] : 2 
          Enter the values of array arr[0][2] : 3
          Enter the values of array arr[1][0] : 4 
          Enter the values of array arr[1][1] : 5 
          Enter the values of array arr[1][2] : 6 
          Enter the values of array arr[2][0] : 7 
          Enter the values of array arr[2][1] : 8 
          Enter the values of array arr[2][2] : 9 
  
          Enter the values of second array : 
  
          Enter the values of arr[0][0] : 1
          Enter the values of arr[0][1] : 2 
          Enter the values of arr[0][2] : 3 
          Enter the values of arr[1][0] : 4 
          Enter the values of arr[1][1] : 5 
          Enter the values of arr[1][2] : 6 
          Enter the values of arr[2][0] : 7 
          Enter the values of arr[2][1] : 8 
          Enter the values of arr[2][2] : 9 
          
          print the values of first array : 1 2 3 4 5 6 7 8 9 
          print the values of second array : 1 2 3 4 5 6 7 8 9 

          subtraction of both matrixes : 1 1 2 2 2 2 - 1 - 3 - 2
      </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 14.Transpose OF A MATRIX </h2>
        <pre>

          int main(){
            int arr1[20][20], transpose[20][20];
            int i = 0, j = 0, row, col;
        
            printf("Enter how many rows u want : ");
            scanf("%d", &row);
            printf("Enter how many cols u want : ");
            scanf("%d", &col);
        
            for (i = 0; i < row; i++)
            {
                for (j = 0; j < col; j++)
                {
                    printf("Enter the values of array arr[%d][%d] : ", i, j);
                    scanf("%d", &arr1[i][j]);
                }
            }
        
            printf("print the values of first array : \n ");
            for (i = 0; i < row; i++)
            {
                for (j = 0; j < col; j++)
                {
                    printf("%d\t", arr1[i][j], " ");
                }
                printf("\n");
            }
        
            // tranpose of both
            for (i = 0; i < row; i++)
            {
                for (j = 0; j < col; j++)
                {
                    transpose[j][i] = arr1[i][j];
                }
            }
            // printing
            printf("transpose of matrixe :\n ");
            for (i = 0; i < row; i++)
            {
                for (j = 0; j < col; j++)
                {
                    printf("%d\t", transpose[i][j]);
                }
                printf("\n");
            }
            return 0;
        } 

    </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
          Enter how many rows u want : 3
          Enter how many cols u want : 3
  
          Enter the values of array arr[0][0] : 1 
          Enter the values of array arr[0][1] : 2 
          Enter the values of array arr[0][2] : 3
          Enter the values of array arr[1][0] : 4 
          Enter the values of array arr[1][1] : 5 
          Enter the values of array arr[1][2] : 6 
          Enter the values of array arr[2][0] : 7 
          Enter the values of array arr[2][1] : 8 
          Enter the values of array arr[2][2] : 9 
  
          Enter the values of second array : 
  
          Enter the values of arr[0][0] : 1
          Enter the values of arr[0][1] : 2 
          Enter the values of arr[0][2] : 3 
          Enter the values of arr[1][0] : 4 
          Enter the values of arr[1][1] : 5 
          Enter the values of arr[1][2] : 6 
          Enter the values of arr[2][0] : 7 
          Enter the values of arr[2][1] : 8 
          Enter the values of arr[2][2] : 9 
          
          print the values of first array : 1 2 3 4 5 6 7 8 9 
          print the values of second array : 1 2 3 4 5 6 7 8 9 

          transpose of matrixe : 1 4 7 
                                 2 5 8 
                                 3 6 9
      </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 15.SCALAR MUTIPLICATION OF A MTRIX </h2>
        <pre>
          int main(){
            int scaler[20][20];
            int i, j, row, col, key;
        
            printf("Enter how many rows u want : ");
            scanf("%d", &row);
            printf("Enter how many cols u want : ");
            scanf("%d", &col);
        
            for (i = 0; i < row; i++)
            {
                for (j = 0; j < col; j++)
                {
                    printf("Enter the values of array arr[%d][%d] : ", i, j);
                    scanf("%d", &scaler[i][j]);
                }
            }
            // printing
            printf("print the values of  array : \n ");
            for (i = 0; i < row; i++)
            {
                for (j = 0; j < col; j++)
                {
                    printf("%d\t", scaler[i][j]);
                }
                printf("\n");
            }
        
            printf("Enter the key u wanna mul by : ");
            scanf("%d", &key);
        
            // scaler array
            for (i = 0; i < row; i++)
            {
                for (j = 0; j < col; j++)
                {
                    scaler[i][j] = scaler[i][j] * key;
                }
            }
            // printf of scaler array
            printf("print the values of scaler array : \n ");
            for (i = 0; i < row; i++)
            {
                for (j = 0; j < col; j++)
                {
                    printf("%d\t", scaler[i][j]);
                }
                printf("\n");
            }
            return 0;
        }

    </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>
          Enter how many rows u want : 3
          Enter how many cols u want : 3
  
          Enter the values of array arr[0][0] : 1 
          Enter the values of array arr[0][1] : 2 
          Enter the values of array arr[0][2] : 3
          Enter the values of array arr[1][0] : 4 
          Enter the values of array arr[1][1] : 5 
          Enter the values of array arr[1][2] : 6 
          Enter the values of array arr[2][0] : 7 
          Enter the values of array arr[2][1] : 8 
          Enter the values of array arr[2][2] : 9 
  
          Enter the values of second array : 
  
          Enter the values of arr[0][0] : 1
          Enter the values of arr[0][1] : 2 
          Enter the values of arr[0][2] : 3 
          Enter the values of arr[1][0] : 4 
          Enter the values of arr[1][1] : 5 
          Enter the values of arr[1][2] : 6 
          Enter the values of arr[2][0] : 7 
          Enter the values of arr[2][1] : 8 
          Enter the values of arr[2][2] : 9 
          
          print the values of first array : 1 2 3 4 5 6 7 8 9 
          print the values of second array : 1 2 3 4 5 6 7 8 9 
          
          Enter the key u wanna mul by : 2 
          print the values of scaler array : 2 4 2 4 2 4 2 4 2
 
      </pre>
      </div>
    </div>
    <div class="question">
      <div class="solve">
        <h2>Ques 16.CREATE A TIC TAC TOE GAME</h2>
        <pre>
          /*  
          #include < stdio.h>
          #include < stdlib.h>
          #include < ctype.h>
          #include < time.h>
          */
char board[3][3];  //initialize the size of board 
const char PLAYER = 'X'; //player or user move is X
const char COMPUTER = 'O'; //computer move is O

void resetBoard(); //set the board initially
void printBoard(); //board print every time whne move is selected
int checkFreeSpaces();//checks positions are empty or not
void playerMove(); //if position exist next move ask
void computerMove();
char checkWinner(); //condition for checking winner
void printWinner(char);//dsplay msg

int main(){
   char winner = ' ';
   char response = ' ';

   do{
      winner = ' ';
      response = ' ';
      resetBoard();

      while(winner == ' ' && checkFreeSpaces() != 0){
         printBoard();//jb tk winner nhi bnta or space bchi hai board ko printkro

         playerMove();//player se oski move puchu
         winner = checkWinner();//hr move ke bad check kro ki vo winner hai?
         if(winner != ' ' || checkFreeSpaces() == 0){
            break;//koi khali space nhi hai to user win kra hai
         }

         computerMove();//computer vi apni bari chlega
         winner = checkWinner();
         if(winner != ' ' || checkFreeSpaces() == 0) {
            break;
         }
      }

      printBoard();//dono ki turn chlne ke bad dsplay kregea board 
      printWinner(winner);//agr winner huga to winner ko call krega

      printf("\nWould you like to play again? (Y/N): ");
      scanf("%c");
      scanf("%c", &response);
      response = toupper(response);
   } while (response == 'Y');

   printf("Thanks for playing!");
   //agr dobara khelni hugi to yes opetion press given into response do while
   //dala hai taki chlta rhe agr no thanks for playing
   return 0;
}

void resetBoard(){
    //print only board with empty space
   for(int i = 0; i < 3; i++){
      for(int j = 0; j < 3; j++){
         board[i][j] = ' ';
      }
   }
}
void printBoard(){
   //print board with move 
   printf(" %c | %c |    %c ", board[0][0], board[0][1], board[0][2]);
   printf("\n---|---|---\n");
   printf(" %c | %c | %c ", board[1][0], board[1][1], board[1][2]);
   printf("\n---|---|---\n");
   printf(" %c | %c | %c ", board[2][0], board[2][1], board[2][2]);
   printf("\n");
}

int checkFreeSpaces(){
    //used to check the space is available or not
   int freeSpaces = 9;//total space have 9

   for(int i = 0; i < 3; i++){//row
      for(int j = 0; j < 3; j++){//col
         if(board[i][j] != ' '){//if not empty
            freeSpaces--;//mtb kuch space fill hai to km krte rhu
         }
      }
   }
   return freeSpaces;//btao kitni bchi hAi 
}
void playerMove(){
   int x;
   int y;

   do {
      printf("Enter row (1-3): ");
      scanf("%d", &x);
      x--;
      printf("Enter column (1-3): ");
      scanf("%d", &y);
      y--;

      if(board[x][y] != ' '){
         printf("Invalid move!\n");
      }
      else{
         board[x][y] = PLAYER;
         break;
      }
   } while (board[x][y] != ' ');
   //do while mai dala hai puchna hai konsi row konse col = pos pr move dlvan hai
   // user ko nhi pta index isliae x-- y--
   //agr phle se move hai os position pr to invalid move
  
}
void computerMove(){
   //creates a seed based on current time
   srand(time(0));
   int x;
   int y;

   if(checkFreeSpaces() > 0) {
      do{
         x = rand() % 3;
         y = rand() % 3;
      } while (board[x][y] != ' ');
      
      board[x][y] = COMPUTER;
   }
   else{
     printWinner(' ');
   }
}
char checkWinner(){
   //check for each row bec i values is changed every time
   for(int i = 0; i < 3; i++){
      if(board[i][0] == board[i][1] && board[i][0] == board[i][2]){
         return board[i][0];
      }
   }
   //check columns
   for(int i = 0; i < 3; i++){
      if(board[0][i] == board[1][i] && board[0][i] == board[2][i]){
         return board[0][i];
      }
   }
   //check left diagonals
   if(board[0][0] == board[1][1] && board[0][0] == board[2][2]){
      return board[0][0];
   }//ryt
   if(board[0][2] == board[1][1] && board[0][2] == board[2][0]){
      return board[0][2];
   }

   return ' ';
}
//conditions = who is win?
void printWinner(char winner){
   if(winner == PLAYER) {
      printf("congrats üòé‚ù§Ô∏èYOU WIN!ü•≥ü•≥");
   }
   else if(winner == COMPUTER){
      printf("ohh ü•∫ü•∫ YOU LOSE!");
   }
   else{
      printf("oppss üëÄ IT'S A TIE!");
   }
}

    </pre>
      </div>
      <div class="output">
        <h1>OUTPUT</h1>
        <pre>

             |   |      
          ---|---|---
             |   |   
          ---|---|---
             |   |   
          Enter row (1-3): 2
          Enter column (1-3): 3

             |   |      
          ---|---|---
           O |   | X 
          ---|---|---
             |   |   
          Enter row (1-3): 1
          Enter column (1-3): 3

             |   | X 
          ---|---|---
           O |   | X 
          ---|---|---
           O |   |   
          Enter row (1-3): 1
          Enter column (1-3): 1

          X  | O | X 
          ---|---|---
           O |   | X 
          ---|---|---
           O |   |   
          Enter row (1-3): 3
          Enter column (1-3): 3

           X | O | X 
          ---|---|---
           O |   | X 
          ---|---|---
           O |   | X 

          congrats üòé‚ù§Ô∏èYOU WIN!ü•≥ü•≥
          Would you like to play again? (Y/N):n
          printf("Thanks for playing!");
          
          
          
      </pre>
      </div>
    </div>
    <!--+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
    <section id="sorting">
      <h1>Sorting</h1>
      <div class="question">
        <div class="solve">
          <h2>Ques 1.Perform bubblesort using function </h2>
          <pre>

            void bubble(int arr[], int n){
              int i, j;
              for (i = 0; i < n - 1; i++){
                for (j = 0; j - i - 1; j++){
                  if (arr[j] > arr[j + 1]){
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                  }
                }
              }
            }
            int main(){
              int n = 6;
              int arr[n];
              
              printf("Enter the elements : ");
              for(int i = 0;i < n;i++){
                  scanf("%d",&arr[i]);
              }
            
              bubble(arr, n);
              printf("Sorted array: ");
              for (int i = 0; i < n; i++)
              {
                printf("%d ", arr[i]);
              }
              return 0;
            }
      </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
          Enter the elements : 1 2 55 0 11 12
          Sorted array: 0 1 2 11 12 55 
        </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 2.Perform selection sort.</h2>
          <pre>

          void selectionSort(int arr[], int n){
            for (int i = 0; i < n - 1; i++){
            int min = i;
            for (int j = i + 1; j < n; j++){
              if (arr[min] > arr[j]){
                min = j;
              }
            }
            int temp = arr[min];
            arr[min] = arr[i];
            arr[i] = temp;
          }
        }
        int main(){
         int n = 6;
         int arr[n];
                      
         printf("Enter the elements : ");
         for(int i = 0;i < n;i++){
         scanf("%d",&arr[i]);
         }
         
          selectionSort(arr, 6);
          printf("Array after soring : ");
          for (int i = 0; i < 6; i++)
          {
            printf("%d\t", arr[i]);
          }
        
          return 0;
        }
      </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
          Enter the elements : 1 4 0 2 6 3
          Array after soring : 0	1	2	3	4	6	
        </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 3.perform insertion sort</h2>
          <pre>

void insertionSort(int arr[], int n){
  for (int i = 1; i < n - 1; i++){
    int curr = arr[i];
    int prev = i - 1;
    // finding out the correct position to insert
    while (prev >= 0 && arr[prev] > curr){
      arr[prev + 1] = arr[prev];
      prev--;
    }
    // insertion
    arr[prev + 1] = curr;
  }
}
int main(){
    
 int n = 6;
 int arr[n];
              
 printf("Enter the elements : ");
 for(int i = 0;i < n;i++){
 scanf("%d",&arr[i]);
 }
 
  insertionSort(arr, 6);
  printf("Array after soring : ");
  for (int i = 0; i < 6; i++){
    printf("%d\t", arr[i]);
  }
 return 0;
}
      </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
          Enter the elements : 4 5 3 6 1 2
          Array after soring : 1	3	4	5	6	2	
        </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 4.Quick sort using Recursion String.</h2>
          <pre>

                  #include < string.h>
                  #include < stdlib.h>

                  int partition(char arr[],int s,int e){
                    char pivot = arr[e];
                    // used to make space for element less than pivot element
                    int i = s - 1;
                    for(int j = s;j <= e;j++){
                        if(strcpm(arr[j],pivot) == -1){
                            i++;
                            int temp = arr[i];
                            arr[i] = arr[j];
                            arr[j] = temp;
                        }
                    }
                    i++;
                    int temp = pivot;
                    arr[e] = arr[i];
                    arr[i] = temp;
                    return i;
                }
                
                void quickSort(char arr[],int s,int e){
                    if(s >= e) return;
                    int pivot = partition(arr,s,e);
                
                    // sort for left part
                    quickSort(arr,s,pivot - 1);
                    quickSort(arr,pivot+1,e);
                }
                
                void main(){
                    char arr[] = "faiz";
                    quickSort(arr,0,4);
                    printArray(arr,5);
                }
              
                
      </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            a f i z 
        </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 5.perform merge sort using Recursion</h2>
          <pre>

     #include < stdio.h>
     #include < string.h>
     #include < stdlib.h>
     //8. Merge Sort
 void merge(int arr[],int s,int m,int e){
     int temp[e-s+1];
     int  i = s,j = m+1,k = 0;
 
     while(i <= m && j <= e){
         if(arr[i] < arr[j]){
             temp[k] = arr[i];
             i++;
         }else {
             temp[k] = arr[j];
             j++;
         }
         k++;
     }
     while(i <= m){
             temp[k] = arr[i];
             i++;
             k++;
     }
      while(j <= e){
         temp[k] = arr[j];
         j++;
         k++;
     }
     for(int i = 0; i < (e-s+1);i++){
         arr[s+i] = temp[i];
     }
 }
 void mergeSort(int arr[],int s,int e){
     if(s >= e) return;
     int mid = (s+e)/2;
     mergeSort(arr,s,mid);
     mergeSort(arr,mid+1,e);
     merge(arr,s,mid,e);
 }
 
 // Print array
 void printArray(int arr[],int n){
     for(int i = 0;i < n;i++){
         printf("%d ",arr[i]);
     }
 }
 
 void main(){
     int arr[] = {4,5,2,1,3};
     mergeSort(arr,0,4);
     printf("Array after soted :");
     printArray(arr,5);
 }
   
      </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
          Enter the elements : 4 5 3 6 1 2
          Array after soring : 1	3	4	5	6	2	
        </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 5.perform Quick sort using Recursion</h2>
          <pre>

void insertionSort(int arr[], int n){
  for (int i = 1; i < n - 1; i++){
    int curr = arr[i];
    int prev = i - 1;
    // finding out the correct position to insert
    while (prev >= 0 && arr[prev] > curr){
      arr[prev + 1] = arr[prev];
      prev--;
    }
    // insertion
    arr[prev + 1] = curr;
  }
}
int main(){
    
 int n = 6;
 int arr[n];
              
 printf("Enter the elements : ");
 for(int i = 0;i < n;i++){
 scanf("%d",&arr[i]);
 }
 
  insertionSort(arr, 6);
  printf("Array after soring : ");
  for (int i = 0; i < 6; i++){
    printf("%d\t", arr[i]);
  }
 return 0;
}
      </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
          Enter the elements : 4 5 3 6 1 2
          Array after soring : 1	3	4	5	6	2	
        </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 5.perform Quick sort using iteration</h2>
          <pre>

      </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
          Enter the elements : 4 5 3 6 1 2
          Array after soring : 1	3	4	5	6	2	
        </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 6.</h2>
          <pre #include < stdio.h>

void buubleSortRe(int arr[],int r,int c,int n){
        if(r < n-1){
          if(c < n-1-r){
              if(arr[c] > arr[c+1]){
                  int temp = arr[c];
                  arr[c] = arr[c+1];
                  arr[c+1] = temp;
              }
              buubleSortRe(arr,r,c+1,n);
          }else {
              buubleSortRe(arr,r+1,0,n);
          }
        }
      }
      void main(){
          int arr[] = {5,4,2,3,1};
          buubleSortRe(arr,0,0,5);
          printArray(arr,5);
      }
  
          
           
              
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            1 2 3 4 5 
        </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 7.selection sort using Recursion</h2>
          <pre>
            #include < stdio.h>
          
              void selectionSortRe(int arr[],int r,int c,int n,int min){
                      if(r >= n-1) return;
                      if(c < n){
                          if(arr[c] < arr[min]){
                              min = c;
                          }
                          selectionSortRe(arr,r,c+1,n,min);
                      }else {
                          int temp = arr[r];
                          arr[r] = arr[min];
                          arr[min] = temp;
                          r = r+1;
                          c = r+1;
                          min = r;
                          selectionSortRe(arr,r,c,n,min);
                      }
                  }
            
      </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            1 2 3 4 5 
        </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 8.Inserting sort using recursion
            Sorting.C</h2>
          <pre>
            #include < stdio.h>
              void insertionSortRec(int arr[],int c,int n){
                      if(c >= n) return;
                      int cur = arr[c];
                        int prev = c-1;
                          while(prev >=0 && arr[prev] > cur){
                              arr[prev + 1] = arr[prev];
                              prev--;
                          }
                      arr[prev+1] = cur;
                      insertionSortRec(arr,c+1,n);
                  }
                  void main(){
                      int arr[] = {5,4,2,3,1};
                      insertionSortRec(arr,0,5);
                      printArray(arr,5);
                  }

                
      </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>

            1 2 3 4 5 
        </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 9.perform Quick sort using Recursion in String</h2>
          <pre>
            #include < stdio.h>
           
              void merge(char arr[],int s,int m,int e){
                      char temp[e-s+1];
                      int  i = s,j = m+1,k = 0;
                  
                      while(i <= m && j <= e){
                          if(arr[i] < arr[j]){
                              temp[k] = arr[i];
                              i++;
                          }else {
                              temp[k] = arr[j];
                              j++;
                          }
                          k++;
                      }
                      while(i <= m){
                              temp[k] = arr[i];
                              i++;
                              k++;
                      }
                       while(j <= e){
                          temp[k] = arr[j];
                          j++;
                          k++;
                      }
                      for(int i = 0; i < (e-s+1);i++){
                          arr[s+i] = temp[i];
                      }
                  }
                  
                  void mergeSort(char arr[],int s,int e){
                      if(s >= e) return;
                      int mid = (s+e)/2;
                      mergeSort(arr,s,mid);
                      mergeSort(arr,mid+1,e);
                      merge(arr,s,mid,e);
                  }
              // Print array
              void printArray(int arr[],int n){
                  for(int i = 0;i < n;i++){
                      printf("%d ",arr[i]);
                  }
              }
              
              void main(){
                  char arr[] = "zaif";
                  mergeSort(arr,0,4);
                  printString(arr,5);
              }
  

      </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            a f i z 
        </pre>
        </div>
      </div>
    </section>
    <!---------------------------------------Searching------------------------------------------->
    <section id="Searching">
      <h1>Searching</h1>
      <div class="question">
        <div class="solve">
          <h2>Ques 1.perform binary search using iteration</h2>
          <pre>


      #include < stdio.h>
      #include < string.h>
      #include < stdlib.h>

      int binarySearch(int arr[],int n,int key){
        int s = 0;
        int e = n-1;
        while(s < e){
            int mid = (s+e)/2;
            if(arr[mid] == key) return mid;
            else if(arr[mid] > key){
                e = mid - 1;
            }else s = mid + 1;
        }
        return -1;
    }
    
    </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
        4
      </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 2.perform linear search using iteration</h2>
          <pre>
              #include < stdio.h>
              #include < string.h>
              #include < stdlib.h>
              int linearSearch(int arr[],int n,int key){
                for(int i = 0;i < n;i++){
                    if(arr[i] == key) return i;
                }
                return -1;
            }
            }  
            void main(){
              int arr[] = {4,5,2,1,3};
              printf("%d ",linearSearch(arr,5,5));
          }
            
  
    </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>

            1	
      </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 3.perform binary search using Recursion</h2>
          <pre>
              #include < stdio.h>
              #include < string.h>
              #include < stdlib.h>
              int binarySearchRec(int arr[],int key,int s,int e){
                if(s > e) return -1;
                int mid = (s+e)/2;
                if(arr[mid] == key) return mid;
                if(arr[mid] > key){
                    return binarySearchRec(arr,key,s,mid - 1);
                }else {
                    return binarySearchRec(arr,key,mid + 1,e);
                }
            }
            
        
          
            
    </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            4 	
      </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 4.perform linear search using Recursion</h2>
          <pre>
              #include < stdio.h>
              #include < string.h>
              #include < stdlib.h>
              int linearSearchRec(int arr[],int n,int key,int i){
                if(i == n){
                    return -1;
                }
                if(arr[i] == key) return i;
            
                return linearSearchRec(arr,n,key,i + 1);
            }
            
            void main(){
                int arr[] = {4,5,2,1,3};
                printf("%d ",linearSearchRec(arr,5,3,0));
            }
            
          
        
            

    </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            4 
      </pre>
        </div>
      </div>
    </section>
    <!---------------------------------string-------------------------------------->
    <section id="String">
      <h1>String</h1>
      <div class="question">
        <div class="solve">
          <h2>Ques 1.Convert string into uppercase</h2>
          <pre>

          int main(){
            char s[100];
            int i;
            printf("\nEnter a string : ");
            scanf("%s",s);
         
            for (i = 0; s[i] != '\0'; i++){
               if (s[i] >= 'a' && s[i] <= 'z'){
                  s[i] = s[i] - 32;
               }
            }
            printf("\nString in Upper Case = %s", s);
            return 0;
         }
      </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
          Enter a string : coding
          String in Upper Case = CODING
        </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 2.Convert into smaller case </h2>
          <pre>

            int main(){
              char s[100];
              int i;
              printf("\nEnter a string : ");
              scanf(" %s", s); // gets(s)
           
              for (i = 0; s[i] != '\0'; i++)
              {
                 if (s[i] >= 'A' && s[i] <= 'Z')
                 {
                    s[i] = s[i] + 32;
                 }
              }
              printf("\nString in smaller Case = %s", s);
              return 0;
           }
        </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            Enter a string : FAHAM
            String in smaller Case = faham
          </pre>
        </div>
      </div>

      <div class="question">
        <div class="solve">
          <h2>Ques 3.convert into sentence case ? </h2>
          <pre>
            #include <stdio.h>
              #include <string.h>
              
              void rev(char string[]){
                  int length = 0, i = 0;
                  for (i = 0; string[i] != '\0'; i++){
                      length++;
                  }
              
                  for (i = 0; i < length; i++){
                      if ((i == 0) && (string[i] >= 'a' && string[i] <= 'z')){
                          string[i] = string[i] - 32;//capital
                      }
                      else if (string[i] == '.'){
                          if (string[i + 1] == ' ') {
                              if (string[i + 2] >= 'a' && string[i + 2] <= 'z'){
                                  string[i + 2] = string[i + 2] - 32;
                              }
                              else{
                                  if (string[i + 1] >= 'a' && string[i + 1] <= 'z'){
                                      string[i + 1] = string[i + 1] - 32;
                                  }
                              }
                          }
                      }
              
                      else if (string[i] == '?'){
                          if (string[i + 1] == ' '){
                              if (string[i + 2] >= 'a' && string[i + 2] <= 'z'){
                                  string[i + 2] = string[i + 2] - 32;
                              }
                              else {
                                  if (string[i + 1] >= 'a' && string[i + 1] <= 'z'){
                                      string[i + 1] = string[i + 1] - 32;
                                  }
                              }
                          }
                      }
                      else if (string[i] == '!'){
                          if (string[i + 1] == ' '){
                              if (string[i + 2] >= 'a' && string[i + 2] <= 'z'){
                                  string[i + 2] = string[i + 2] - 32;
                              }
                              else{
                                  if (string[i + 1] >= 'a' && string[i + 1] <= 'z'){
                                      string[i + 1] = string[i + 1] - 32;
                                  }
                              }
                          }
                      }
                  }
              }
              
              void main(){
                  char Sentence[100];
                  puts("Enter your sentence : ");
                  gets(Sentence);
                  rev(Sentence);
                  printf("Sentence now is : %s", Sentence);
              }

          </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            Enter your sentence : 
            i love coding. i want to become software developer
            Sentence now is : I love coding. I want to become software developer
            </pre>
        </div>
      </div>

      <div class="question">
        <div class="solve">
          <h2>Ques 4.convert into title case ?</h2>
          <pre>

            void title(char word[]){
              int length = 0, i = 0;
              for (i = 0; word[i] != '\0'; i++){
                  length++;
              }
              for (i = 0; i < length; i++){
              if ((word[i] >= 'a' && word[i] <= 'z') || (word[i] >= 'A' && word[i] <='Z')){
                  if (i == 0 || word[i - 1] == ' '){
                        if (word[i] >= 'a' && word[i] <= 'z'){
                              word[i] = word[i] - 32; // between 97 to 122
                          }
                      }
                      else {
                        // for lower case, if any upper case found besides desired ones.
                          if (word[i] >= 'A' && word[i] <= 'Z'){ 
                              word[i] = word[i] + 32;
                          }
                      }
                  }
              }
          }
          void main(){
              char Sentence[100];
              puts("Enter the text : ");
              gets(Sentence);
              title(Sentence);
              printf("Sentence after title text convert : %s", Sentence);
          }

            </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            Enter the text : 
            hello everyone kese hu
            Sentence after title text convert : Hello Everyone Kese Hu 
              </pre>
        </div>
      </div>

      <div class="question">
        <div class="solve">
          <h2>Ques 5.convert into toggle case ?</h2>
          <pre>

            void toggle(char word[]){
              int i = 0;
              for (i = 0; word[i] != '\0'; i++){
                  if (word[i] >= 97 && word[i] <= 122){
                      word[i] = word[i] - 32;
                  }
                  else if(word[i] >= 65 && word[i] <= 90){
                      word[i] = word[i] + 32;
                  }
              }
          }
          void main(){
              char Sentence[100];
              puts("Enter the text : ");
              gets(Sentence);
              toggle(Sentence);
              printf("Sentence after title text convert : %s", Sentence);
          }

          </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            Enter the text : 
            heLLO How Are u
            Sentence after title text convert : HEllo hOW aRE U    
          </pre>
        </div>
      </div>

      <div class="question">
        <div class="solve">
          <h2>Ques 6.final length of the string ?</h2>
          <pre>
            #include < stdio.h >
            #include < string.h >

              int len(char word[]){
                  int length = 0, i = 0;
                  for (i = 0; word[i] != '\0'; i++)
                  {
                      length++;
                  }
                  return length;
              }
              void main()
              {
                  char Sentence[100];
                  int lenght;
                  puts("Enter the text : ");
                  gets(Sentence);
                  lenght=len(Sentence);
                  printf("Length is : %d",lenght);
              }

        </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            Enter the text : 
            faham
            Length is : 5
          </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 7.compare those string ?</h2>
          <pre>
            #include < stdio.h >
            #include < string.h >
              int compare(char word[],char word2[]){
                  int comp = -1;
                  int length2=0,length1 = 0, i = 0,incr=0;
                  for (i = 0; word[i] != '\0'; i++){
                      length1++;
                  }
                  for (i = 0; word2[i] != '\0'; i++){
                      length2++;
                  }
                  if (length1!=length2){
                      return comp;
                  }
                  for ( i = 0; i < length1; i++){
                      if (word[i]==word2[i]){
                          incr++;
                      }
                      
                  }
                  if (incr==length1 && incr == length2){
                      comp=incr;
                      return comp;
                  }
                  else{
                      return -1;
                  }
                  
              }
              void main(){
                  char Sentence1[100],Sentence2[100];
                  int comp=0;
                  puts("Enter the text : ");
                  gets(Sentence1);
                  puts("Enter the text2 : ");
                  gets(Sentence2);
                  comp=compare(Sentence1,Sentence2);
                  if (comp==-1)
                  {
                      printf("\nSentence are differnt.------!");
                  }
                  else{
                      printf("\nSentences are same with given length = %d",comp);
                  }
              }
              </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            Enter the text : 
            faham
            Enter the text2 : 
            faham
            Sentences are same with given length = 5
          </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 8.concatenate the string ?</h2>
          <pre>
            #include <stdio.h>
              // concatenate two strings
              
              int main(){
                  char str[] = "faham";
                  char str1[] = "naz";
                  char copy[20];
                  int i, j;
              
                  printf("The first string is : %s \n", str);
                  printf("The second string is : %s \n", str1);
                  for (i = 0; str[i] != '\0'; i++)
                  {
                      copy[i] = str[i];
                  }
                  for (j = 0; str1[j] != '\0'; j++)
                  {
                      copy[i + j] = str1[j];
                  }
                  printf("The string after concatenate : %s", copy);
              
                  return 0;
              }
            </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            The first string is : faham 
            The second string is : naz 
            The string after concatenate : fahamnaz
              </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 9.copy that string into another string ?</h2>
          <pre>
            #include < stdio.h >
            #include < string.h >
              void copy(char word[], char cpy[]){
                  int i = 0;
                  for (i = 0; word[i] != '\0'; i++) {
                      cpy[i] = word[i];
                  }
              }
              void main(){
                  char Sentence[100], coppied[100];
                  puts("Enter the text : ");
                  gets(Sentence);
                  copy(Sentence, coppied);
                  printf("Coppied sentence can be seen as follow : %s", coppied);
              }
          </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            Enter the text : 
            faham
            Coppied sentence can be seen as follow : faham
           </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 10.enter bound number and print character on that bound ?</h2>
          <pre>
            #include < stdio.h >
            #include < string.h >
            #include < stdlib.h >
              
              char specific(char word[], int find){
                  int length = 0, i = 0;
                  char ch='1';
                  for (i = 0; word[i] != '\0'; i++){
                      length++;
                  }
                  if (find > length)
                  {
                      return ch;
                  }
                  ch = word[find-1];
                  return ch;
              }
              void main(){
                  char Sentence[100], bnd[5], ch;
                  int bound = 0;
                  puts("Enter the text : ");
                  gets(Sentence);
                  puts("Enter the bound number to show what character is there : ");
                  gets(bnd);
                  bound = atoi(bnd);
                  ch = specific(Sentence, bound);
                  if (ch == '1')
                  {
                      printf("\nWarnin!! input error");
                  }
                  else
                  {
                      printf("\nWord at given index is  : %c", ch);
                  }
              }
        </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            Enter the text : 
            faham bhut achi h
            Enter the bound number to show what character is there : 5
            Word at given index is  : m
          </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 11.check its palindrome or not?</h2>
          <pre>
          #include < stdio.h >
          #include < string.h >
          int palindrome(char word[]){
              int last_length = 0, i = 0;
              int front=0;//index of first element in a sentence
       
           for (i = 0; word[i] != '\0'; i++){
               last_length++;//this will give us the last element's index
           }
           while (front>last_length){
               if (word[front++]!=word[last_length--]) {
                   return -1;
               }
           }
           return 1;
       }
       void main(){
           char Sentence[100];
           int result=-1;
           puts("Enter the text : ");
           gets(Sentence);
           result=palindrome(Sentence);
           if (result==-1){
           printf("\nEntered string is not a palindrome");
           }
           else{
               printf("\nString is a palindrome");
           }
       }
        </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            Enter the text : 
            abcba
            String is a palindrome
          </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 12.print each character in new line ?</h2>
          <pre>
            void main(){
              char Sentence[100];
              int i;
              puts("Enter the text : ");
              gets(Sentence);
              for ( i = 0; Sentence[i]!='\0'; i++){
                  printf("%c\n",Sentence[i]);
              }
           }
        </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            Enter the text : 
            faham
            f
            a
            h
            a
            m
             
          </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 13.copy reverse order into another string ?</h2>
          <pre>
            #include < stdio.h >
            #include < string.h >
              void copy(char word[], char cpy[]){
                  int i;
                   int length1 = 0;
                  for (i = 0; word[i] != '\0'; i++){
                      length1++;
                  }
                  int temp=length1-1;
                  for (i = 0; i < length1; i++){
                      cpy[temp]=word[i];
                      temp--;
                  }
              }
              void main(){
                  char Sentence[100], coppied[100];
                  puts("Enter the text : ");
                  gets(Sentence);
                  copy(Sentence, coppied);
                  printf("Coppied sentence which is reversed can be seen as follow : %s", coppied);
              }
        </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            Enter the text : 
            faham
            Coppied sentence which is reversed can be seen as follow : mahaf 
          </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 14. 2 strings and print difference each character ?</h2>
          <pre>
            #include < stdio.h >
            #include < string.h >

              void compare(char word[], char word2[]){
                  int length2 = 0, length1 = 0, i = 0, rec = 0;
                  for (i = 0; word[i] != '\0'; i++){
                      length1++;
                  }
                  for (i = 0; word2[i] != '\0'; i++){
                      length2++;
                  }
                  if (length1 != length2){
                      printf("\nEven the lengths of strings do not match");
                  }
                  for (i = 0; i < length1; i++){
                      if (word[i] != word2[i]){
                          printf("\nWord maismath found : ");
                          printf("\n %c - %c ", word[i], word2[i]);
                          printf("\nat position %d", i);
                          rec++;
                      }
                  }
                  if (length1 > length2){
                      while (word[rec] != '\0'){
                          printf("\nLength is longer than other string. Words are: ");
                          printf("\n %c ", word[rec]);
                          rec++;
                      }
                  }
                  if (length2 > length1) {
                      while (word2[rec] != '\){
                          printf("\nLength is longer than other string. Words are: ");
                          printf("\n %c ", word[rec]);
                          rec++;
                      }
                  }
              }
              void main(){
                  char Sentence1[100], Sentence2[100];
                  puts("Enter the text : ");
                  gets(Sentence1);
                  puts("Enter the text2 : ");
                  gets(Sentence2);
                  compare(Sentence1, Sentence2);
              }
        </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            Enter the text : 
            hello
            Enter the text2 : 
            hyyyy
            Word maismath found : 
             e - y 
            at position 1
            Word maismath found : 
             l - y 
            at position 2
            Word maismath found : 
             l - y 
            at position 3
            Word maismath found : 
             o - y 
            at position 4
          </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 15.enter a character , it is exist or not ?</h2>
          <pre>
            #include < stdio.h >
              void findCharExist(char str[],char find){
                  for(int i = 0;str[i]!='\0';i++){
                      if(str[i] == find){
                          printf("char is found \n");
                          return;
                      }
                  }
                  printf("char is not found \n");
              }
              int main() {
                  char Sentence1[100],find;
              
                  puts("Enter the text : ");
                  gets(Sentence1);
                  puts("Enter the character you want to search : ");
                  find=getchar();
                  findCharExist(Sentence1,find);
              
                  return 0;
              }
        </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            Enter the text : 
            faham
            Enter the character you want to search : 
            h
            char is found  
          </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 16.enter a character if it is exist then print the bound number ?</h2>
          <pre>
              #include < stdio.h >
              #include < string.h >
              #include < stdlib.h >
              
              char specific(char word[], int find){
                  int length = 0, i = 0;
                  char ch='1';
                  for (i = 0; word[i] != '\0'; i++){
                      length++;
                  }
                  if (find > length)
                  {
                      return ch;
                  }
                  ch = word[find-1];
                  return ch;
              }
              void main(){
                  char Sentence[100], bnd[5], ch;
                  int bound = 0;
                  puts("Enter the text : ");
                  gets(Sentence);
                  puts("Enter the bound number to show what character is there : ");
                  gets(bnd);
                  bound = atoi(bnd);
                  ch = specific(Sentence, bound);
                  if (ch == '1')
                  {
                      printf("\nWarnin!! input error");
                  }
                  else
                  {
                      printf("\nWord at given index is  : %c", ch);
                  }
              }
        </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            Enter the text : 
            hyy everyone
            Enter the bound number to show what character is there : 
            5
            letter at given index is  : e
          </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 17.count all vowels ?</h2>
          <pre>
            #include <stdio.h>
              #include <string.h>
              int vowelcount(char word[]){
                  int i = 0, vowel_count = 0; 
                  // taking zero becaz there might be a possibility that no vowels exist.
                  while (word[i] != '\0') {
                  //for lower case checking
              if (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'){
                          vowel_count++;
                      }
                      //for upper case checking
              if (word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U'){
                  vowel_count++;
              }
                      i++;
              }
                  return vowel_count;
              }
              void main(){
                  char Sentence1[100];
                  int comp = 0;
                  puts("Enter the text : ");
                  gets(Sentence1);
                  comp = vowelcount(Sentence1);
                  printf("Number of vowels found are: %d", comp);
              }
        </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            Enter the text : 
            hello kese hu sb
            Number of vowels found are: 5
          </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 18.convert into integer?</h2>
          <pre>
            #include < stdio.h >
              int convert_to_int(char word[]){
                 
                  int i, num = 0;
                  // 48 to 57 are 0 to 9
                  for (i = 0; word[i] != '\0'; i++){
                      num = num * 10 + (word[i] - 48);
                  }
                  return num;
              }
              
              void main(){
                  char Sentence1[100];
                  int change_to_int = 0;
                  puts("Enter the text : ");
                  gets(Sentence1);
                  change_to_int = convert_to_int(Sentence1);
                  printf("Integer value is : %d", change_to_int);
              }
        </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            Enter the text : 
            a
            Integer value is : 49
          </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 19.convert into float?</h2>
          <pre>
            #include < stdio.h >
              float convertIntoFloat(char str1[]){
                 int integer = 0;
                  int i = 0;
                  while(str1[i] != 46){
                    integer = integer*10 + (str1[i] - '0');
                    i++;
                  }
                  float decimal = 0;
                  i++;
                  while(str1[i]){
                    decimal = decimal*10 + (str1[i] - '0');
                    i++;
                  }
                  while(decimal > 1){
                      decimal /= 10;
                  }
                  float ans = integer + decimal;
                  return ans;
              }
              int main() {
                  char str[100];
                  printf("Enter string : ");
                  gets(str);
                  float ans = convertIntoFloat(str);
                  printf("ans is %f",ans);
                  return 0;
              }
        </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            Enter string : 28.106
            ans is 28.106001 
          </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 20.convert into character?</h2>
          <pre>
            #include < stdio.h>
              #include < string.h>
              void change_to_ch(char word[], char ary[]){
                  int length1 = 0, i = 0;
                  for (i = 0; word[i] != '\0'; i++){
                      length1++;
                  }
                  for (i = 0; i < length1; i++){
                      ary[i] = word[i];
                  }
                  for (i = 0; i < length1; i++)
                  {
                      printf("%c ,", ary[i]);
                  }
              }
              
              void main(){
                  char Sentence1[100], access[100];
                  puts("Enter the text : ");
                  gets(Sentence1);
                  change_to_ch(Sentence1, access);
              }
        </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            Enter the text : 
            hello everyone
            h ,e ,l ,l ,o ,  ,e ,v ,e ,r ,y ,o ,n ,e ,
          </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 21. print all the possiblities of a string i.e. "abcd".</h2>
          <pre>
            #include < stdio.h >
              void possiblePair(char str[], int n){
              int i, j, k;
              for (i = 0; i < n; i++ )  {
                  for (j = i + 1; j < n; j++){
                      for (k = i; k <= j; k++){
                          printf("%c", str[k]);
                      }
                      printf("\n");
                  }
                  }
              }
              int main(){
                  char str[] = "abcd";
                  int n = sizeof(n);
                  possiblePair(str, n);
              
                  return 0;
              }
        </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            ab
            abc
            abcd
            bc
            bcd
            cd
          </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 23.sort the string in ascending order.</h2>
          <pre>

            void ConvertInAcsending(char str[]){
              int length = 0,i = 0,j;
              //find the length of the string
              for(i = 0;str[i] != '\0';i++){
                  length++;
              }
              //convert into acsending order
              //bubble sort
              for(i = 0;i < length;i++){
                  for(j = 0;j < length-i-1;j++){
                      if(str[j] > str[j+1]){
                          char temp = str[j];
                          str[j] = str[j+1];
                          str[j+1] = temp;
                      }
                  }
              }
              for (i = 0; i < length; i++){
                  printf("%c\t", str[i]);
              }
          }
          int main() {
              char str[100];
              printf("Enter a string :");
              gets(str);
              ConvertInAcsending(str);
              return 0;
          }
              
        </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            Enter a string : i love coding
            c	d	e	g	i	i	l	n	o	o	v	
          </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 24.enter a sentence from user and then enter the letter and count the occurence of that letter in the
            sentence.</h2>
          <pre>
            #include < stdio.h >
            #include < string.h >
              int count_ch(char word[], char input[]){
                  int length_sentence = 0, length_word, i = 0, j;
                  int temp, count_word = 0, chk = 0;
                  for (i = 0; word[i] != '\0'; i++){
                      length_sentence++;
                  }
                  length_word = strlen(input);
                  for (i = 0; i < length_sentence; i++){
                      temp = i;
                      for (j = 0; j < length_word; j++){
                          if (word[i] == input[j])
                              i++;
                          chk = i - temp;
                          if (chk == length_word)
                              count_word++;
                          i=temp;
                      }
                  }
                  return count_word;
              }
              void main(){
                  char Sentence1[100], word[20];
                  int comp = 0;
                  puts("Enter the text : ");
                  gets(Sentence1);
                  puts("Enter the character to search : ");
                  gets(word);
                  comp = count_ch(Sentence1,word);
                  printf("Number occured %d times", comp);
              }
        </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            Enter the text : 
            faham naz
            Enter the character to search : 
            a
            Number occured 3 times
          </pre>
        </div>
      </div>
      <div class="question">
        <div class="solve">
          <h2>Ques 25.enter a sentence from user and then enter the word and replace that word by another word.</h2>
          <pre>
            #include < stdio.h>
              #include < string.h>
              void count(char word[]){
                  int i = 0, char_count = 0, word_count = 0, space_count = 0;
              
                  while (word[i] != '\0'){
                      if (word[i]!= ' '){
                          char_count++;
                      }
                      if (word[i] == 32){
                          space_count++;
                      }
              
                      if (word[i] == 32 && word[i+1] !=32){
                          word_count++;
                      }
                      
                      i++;
                  }
                  printf ("total chars %d\n",char_count);
                  printf("total spaces %d\n",space_count);
                  printf("total words  %d\n",word_count+1);
              }
              void main(){
                  char Sentence1[100];
                  puts("Enter the text : ");
                  gets(Sentence1);
                  count(Sentence1);
                  //printf("Number of vowels found are: %d", comp);
              }
        </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            Enter the text : 
            heloo kese hu sb
            total chars 13
            total spaces 3
            total words  4
            
          </pre>
        </div>
      </div>



      <div class="question">
        <div class="solve">
          <h2>Ques 26.create a dictionary having 10 words and their meaning with following operations. [create,
            delete,search]</h2>
          <pre>
              #include < stdio.h>
              #include < conio.h>
              void dictionary(){
                      char words[10][100];
                      char meanings[10][100];
                  
                  
                      char word[30],meaning[30];
                      int i = 0;
                      char choice;
                      while(choice != '4'){
                        printf("
              ****MENU*****
              1.Create
              2.Delete
              3.Search
              4.Exit
              ");
    fflush(stdin);
    choice = getchar();
    switch(choice){
      case '1':
      printf("Add a word : ");
      scanf("%s",word);
      printf("Add meaning of word : ");
      scanf("%s",meaning);
      strcpy(words[i],word);
      strcpy(meanings[i],meaning);
      i++;
      break;
      case '2':
      printf("
      Enter a word to be deleted: 
      ");
      char word[30];
      scanf("%s",word);
      int delIndx = -1;
      for(int i = 0; i < 10;i++){
          if(strcmp(words[i],word) == 0) {
              delIndx = i;
              break;
          }
      }
      if(delIndx == -1) {
          printf("Word does not exits!");
          break;
      }
      // left shifting elements.
      for(int i = delIndx;i < 9;i++){
          strcpy(words[i],words[i+1]);
          strcpy(meanings[i],meanings[i+1]);
      }
      i--;
      break;
      case '3':
      printf("Enter a word to be searched : ");
      scanf("%s",word);
      int indx = -1;
      for(int i = 0; i < 10;i++){
          if(strcmp(words[i],word) == 0) {
              indx = i;
              break;
          }
      }
      if(indx != -1) printf("\n Meaning of the %s is :
       %s\n ",word,meanings[indx]);

      else  printf("Word does not exits!");
      break;
    }
    
  }
  
  void main(){
      dictionary();
  }   
                  
                  
                
             
        </pre>
        </div>
        <div class="output">
          <h1>OUTPUT</h1>
          <pre>
            ****MENU*****
            1.Create     
            2.Delete     
            3.Search     
            4.Exit       
            1
            Add a word : apple
            Add meaning of word : saib
            
            ****MENU*****
            1.Create     
            2.Delete     
            3.Search     
            4.Exit       
            1
            Add a word : mango
            Add meaning of word : aam
            
            ****MENU*****
            1.Create     
            2.Delete     
            3.Search     
            4.Exit       
            3
            Enter a word to be searched : grapes
            Word does not exits!
            ****MENU*****       
            1.Create
            2.Delete
            3.Search
            4.Exit
            3
            Enter a word to be searched : chiko
            Word does not exits!
            ****MENU*****
            1.Create
            2.Delete
            3.Search
            4.Exit
            3
            Enter a word to be searched : mango
            
            Meaning of the mango is : aam 

          </pre>
        </div>
      </div>

      <!-------------------------------SORTING----------------------------------------------------------------->
      <section id="sorting">
        <h1>Sorting</h1>
        <div class="question">
          <div class="solve">
            <h2>Ques 1. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH ITERATION. ALSO
              CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</h2>
            <pre>
              #include < stdio.h >
              #include < time.h >
                
                // Function to perform Bubble Sort by recursion
                void bubble_rec(int arr[], int n){
                    int i, temp;
                    if (n == 1){
                        return; // 1 element is always sorted
                    }
                
                    // One pass of Bubble Sort to move the largest element to the end
                    for (i = 0; i < n - 1; i++){
                        if (arr[i] > arr[i + 1]){
                            // Swap arr[i] and arr[i + 1]
                            temp = arr[i];
                            arr[i] = arr[i + 1];
                            arr[i + 1] = temp;
                        }
                    }
                
                    // Recursively sort the remaining (n-1) elements
                    // so every time it will sort 1 element
                    bubble_rec(arr, n - 1);
                }
                int main(){
                    int i, n;
                    printf("Enter the number of elements in the array: ");
                    scanf("%d", &n);
                
                    int arr[n];
                    printf("Enter %d integers:\n", n);
                    for (i = 0; i < n; i++){
                        scanf("%d", &arr[i]);
                    }
                
                    // Record the start time
                    clock_t start = clock();
                
                    // Perform Bubble Sort
                    bubble_rec(arr, n);
                
                    // Record the end time
                    clock_t end = clock();
                
                    printf("Sorted array using Bubble Sort(recursion):\n");
                    for (i = 0; i < n; i++){
                        printf("%d ", arr[i]);
                    }
                    printf("\n");
                
                    // Calculate the time taken in seconds
                    double time_complexity = ((double)(end - start)); // CLOCKS_PER_SEC;
                    printf("\nTime taken: %f seconds\n", time_complexity);
                
                    return 0;
                }
            </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>

              Enter the number of elements in the array: 5
              Enter 5 integers:
              4 2 3 4 1
              Sorted array using Bubble Sort(recursion):
              1 2 3 4 4 
              
              Time taken: 1.000000 seconds
             </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 2. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH RECURSION. ALSO
              CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</h2>
            <pre>
              #include< stdio.h >
              #include< time.h >
                
                int select(int ary[],int size){
                    int i,j,min,temp;
                    for ( i = 0; i < size-1; i++){
                        min=i;
                        for ( j = i+1; j < size; j++){
                            if (ary[j] < ary[min]){
                                min=j;
                            }   
                        }
                        temp=ary[i];
                        ary[i]=ary[min];
                        ary[min]=temp;
                        
                    }
                    return 0;
                }
                void main(){
                    
                    int ary[10], i, count;
                    printf("Enter your array size : ");
                    scanf("%d", &count);
                    
                    for (i = 0; i < count; i++){
                        printf("\nEnter %d value : ", i + 1);
                        scanf("%d", &ary[i]);
                    }
                    clock_t start=clock();
                    select(ary,count);
                    clock_t end=clock();
                    
                    double time_complexity=((double)(end-start))/CLOCKS_PER_SEC;
                    
                    for ( i = 0; i < count; i++){
                        printf("%d,",ary[i]);
                    }
                    printf("\nTime taken: %f seconds\n", time_complexity);
                    
                }
            </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
                        Enter the elements : 1 2 55 0 11 12
                        Sorted array: 0 1 2 11 12 55 
                      </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 3. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH ITERATION. ALSO
              CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</h2>
            <pre>
              void bubble(int arr[], int n){
                int i, j;
                for (i = 0; i < n - 1; i++){
                  for (j = 0; j - i - 1; j++){
                    if (arr[j] > arr[j + 1]){
                      int temp = arr[j];
                      arr[j] = arr[j + 1];
                      arr[j + 1] = temp;
                    }
                  }
                }
              }
              int main(){
                int n = 6;
                int arr[n];
                
                printf("Enter the elements : ");
                for(int i = 0;i < n;i++){
                    scanf("%d",&arr[i]);
                }
              
                bubble(arr, n);
                printf("Sorted array: ");
                for (int i = 0; i < n; i++)
                {
                  printf("%d ", arr[i]);
                }
                return 0;
              }
            </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
              Enter your array size : 10
              Enter 1 value : 1
              Enter 2 value : 12
              Enter 3 value : 14
              Enter 4 value : 5
              Enter 5 value : 9
              Enter 6 value : 10
              Enter 7 value : 58
              Enter 8 value : 63
              Enter 9 value : 12
              Enter 10 value : 18
              1,5,9,10,12,12,14,18,58,63,
              Time taken: 0.000001 seconds
              </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 4. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH RECURSION. ALSO
              CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</h2>
            <pre>
              #include < stdio.h >
              #include < time.h >
                
                // Function to perform Bubble Sort
                void bubble(int arr[], int n) {  
                  int i, j;  
                  for (i = 0; i < n - 1; i++) {  
                    for (j = 0; j < n - i - 1; j++) {  
                      if (arr[j] > arr[j + 1]) {  
                        int temp = arr[j];  
                        arr[j] = arr[j + 1];  
                        arr[j + 1] = temp;  
                      }  
                    }  
                  }  
                }  
                
                int main() {
                    int i,n;
                    printf("Enter the number of elements in the array: ");
                    scanf("%d", &n);
                
                    int arr[n];
                    printf("Enter %d integers:\n", n);
                    for (i = 0; i < n; i++) {
                        scanf("%d", &arr[i]);
                    }
                
                    // Record the start time
                    clock_t start = clock();
                
                    // Perform Bubble Sort
                    bubble(arr, n);
                
                    // Record the end time
                    clock_t end = clock();
                
                    printf("Sorted array using Bubble Sort:\n");
                    for (i = 0; i < n; i++) {
                        printf("%d ", arr[i]);
                    }
                    printf("\n");
                
                    // Calculate the time taken in seconds
                    double timeTaken = ((double)(end - start)) / CLOCKS_PER_SEC;
                    printf("Time taken: %f seconds\n", timeTaken);
                
                    return 0;
                }
            </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
              Enter the number of elements in the array: 5
              Enter 5 integers:
              1 4 5 10 3
              Sorted array using Bubble Sort:
              1 3 4 5 10 
              Time taken: 0.000002 seconds
              </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 5. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH ITERATION. ALSO
              CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</h2>
            <pre>
              #include <stdio.h>
                #include <time.h>
                
                int insort(int ary[], int size){
                    int key, i, j;
                    for (i = 1; i < size; i++){
                        key = ary[i];
                        j = i - 1;
                        while (j >= 0 && ary[j] > key){
                            ary[j + 1] = ary[j];
                            j--;
                        }
                        ary[j + 1] = key;
                    }
                    return 0;
                }
                
                void main(){
                    int ary[10], i, count;
                    printf("Enter your array size : ");
                    scanf("%d", &count);
                    
                    for (i = 0; i < count; i++){
                        printf("\nEnter %d value : ", i + 1);
                        scanf("%d", &ary[i]);
                    }
                    clock_t start = clock();
                    insort(ary, count);
                    clock_t end = clock();
                    
                    for (i = 0; i < count; i++){
                        printf("%d,", ary[i]);
                    }
                    double time_complexity = ((double)(end - start)) / CLOCKS_PER_SEC;
                    printf("\nTime taken: %f seconds\n", time_complexity);
                }
            </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
              Enter your array size : 5
              Enter 1 value : 1
              Enter 2 value : 25
              Enter 3 value : 11
              Enter 4 value : 16
              Enter 5 value : 18
              1,11,16,18,25,
              Time taken: 0.000002 seconds
               </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 6. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH RECURSION. ALSO
              CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</h2>
            <pre>

            </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
                        Enter the elements : 1 2 55 0 11 12
                        Sorted array: 0 1 2 11 12 55 
                      </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>7. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH ITERATION. ALSO
              CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</h2>
            <pre>

            </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
                        Enter the elements : 1 2 55 0 11 12
                        Sorted array: 0 1 2 11 12 55 
                      </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 8. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH RECURSION. ALSO
              CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME..</h2>
            <pre>

            </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
                        Enter the elements : 1 2 55 0 11 12
                        Sorted array: 0 1 2 11 12 55 
                      </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 9. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH ITERATION. ALSO
              CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</h2>
            <pre>

            </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
                        Enter the elements : 1 2 55 0 11 12
                        Sorted array: 0 1 2 11 12 55 
                      </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 10. ENTER A INTEGER ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH RECURSION. ALSO
              CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</h2>
            <pre>

            </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
                        Enter the elements : 1 2 55 0 11 12
                        Sorted array: 0 1 2 11 12 55 
                      </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 11. ENTER A STRING ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH ITERATION. ALSO
              CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</h2>
            <pre>

            </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
                        Enter the elements : 1 2 55 0 11 12
                        Sorted array: 0 1 2 11 12 55 
                      </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 12. ENTER A STRING ARRAY FROM THE USER AND PERFORM SELECTION SORT ALGORITHM THROUGH RECURSION. ALSO
              CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</h2>
            <pre>

            </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
                        Enter the elements : 1 2 55 0 11 12
                        Sorted array: 0 1 2 11 12 55 
                      </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 13. ENTER A STRING ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH ITERATION. ALSO
              CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</h2>
            <pre>

            </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
                        Enter the elements : 1 2 55 0 11 12
                        Sorted array: 0 1 2 11 12 55 
                      </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 14. ENTER A STRING ARRAY FROM THE USER AND PERFORM BUBBLE SORT ALGORITHM THROUGH RECURSION. ALSO
              CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME..</h2>
            <pre>

            </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
                        Enter the elements : 1 2 55 0 11 12
                        Sorted array: 0 1 2 11 12 55 
                      </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 15. ENTER A STRING ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH ITERATION. ALSO
              CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</h2>
            <pre>

            </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
                        Enter the elements : 1 2 55 0 11 12
                        Sorted array: 0 1 2 11 12 55 
                      </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 16. ENTER A STRING ARRAY FROM THE USER AND PERFORM INSERTION SORT ALGORITHM THROUGH RECURSION. ALSO
              CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME..</h2>
            <pre>

            </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
                        Enter the elements : 1 2 55 0 11 12
                        Sorted array: 0 1 2 11 12 55 
                      </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 17. ENTER A STRING ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH ITERATION. ALSO
              CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</h2>
            <pre>

            </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
                        Enter the elements : 1 2 55 0 11 12
                        Sorted array: 0 1 2 11 12 55 
                      </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 18. ENTER A STRING ARRAY FROM THE USER AND PERFORM MERGE SORT ALGORITHM THROUGH RECURSION. ALSO
              CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</h2>
            <pre>

            </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
                        Enter the elements : 1 2 55 0 11 12
                        Sorted array: 0 1 2 11 12 55 
                      </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 19. ENTER A STRING ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH ITERATION. ALSO
              CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</h2>
            <pre>

            </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
                        Enter the elements : 1 2 55 0 11 12
                        Sorted array: 0 1 2 11 12 55 
                      </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 20. ENTER A STRING ARRAY FROM THE USER AND PERFORM QUICK SORT ALGORITHM THROUGH RECURSION. ALSO
              CALCULATE THE WORST AND BEST COMPLEXITY WITH EXACT TIME.</h2>
            <pre>

            </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
                        Enter the elements : 1 2 55 0 11 12
                        Sorted array: 0 1 2 11 12 55 
                      </pre>
          </div>
        </div>
      </section>
      <!---------------------------------STACK----------------------------------------------->
      <section id="stack">
        <h1>Stack</h1>
        <div class="question">
          <div class="solve">
            <h2>Ques 1. CREATE A STACK IMPLEMENTING THE OPERATIONS ON AN INTEGER ARRAY (PUSH, POP, PEEK, ISEMPTY,
              ISFULL)</h2>
            <pre>

#include < stdio.h >
#include < stdlib.h >
#define MAX 20
  
  int top = -1;
  int isEmpty(){
    if (top == -1)  return 1;
    return 0;
  }
  
  int isFull(){
    if (top == MAX)return 1; // true
    return 0;//false
  }
  
  int push(int stack[], int item, int top){
    if (isFull()){
      return -1;
    }
      top++;
      printf("Enter value : ");
      scanf("%d", &item);
      stack[top] = item;
      return top;
    }
  
  int pop(int stack[], int item, int top){
    if (isEmpty()){
      return -1;
    }
      top--;
      return top;
  }
  
  int peek(int stack[], int item, int top){
    if (isEmpty()){
      return -1;
    }
  
    return top;
  }
  
  void main(){
    int stack[MAX];
    int item;
    int op, i;
  
    while (1){
      printf("Enter a choice : \n");
      printf("1)push \t 2)pop \t 3)peek  4) isFull \t 5)isEmpty \t 6)exit \n");
      scanf("%d", &op);
  
      switch (op){
  
      case 1:
        top = push(stack, item, top);
        if (top == MAX){
          printf("stack is full : ");
        }
        else{
          printf("The top value is : %d \n", stack[top]);
        }
        break;
      case 2:
        top = pop(stack, item, top);
        if (top == -1){
          printf("The stack is empty :\n");
        }
        else{
          printf("The pop value is : %d \n", stack[top]);
        }
        break;
  
      case 3:
        top = peek(stack, item, top);
        if (top == -1){
          printf("The stack is empty :\n ");
        }
        else{
          printf("The peek value is : %d \n", stack[top]);
        }
          break;

        case 4:
      if( isFull() == 1){
      printf("stack is full\n");
      }else  printf("stack has space now\n");
          break;

        case 5:
         if(isEmpty() == 1){
          printf("stack is full\n");
      }else printf("stack is empty\n");
          break;

        case 6:
          exit(0);
  
        default:
          printf("Invalid choice\n");
        }
      }
    }
  
</pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
Enter a choice : 
1)push 	 2)pop 	 3)peek  4) isFull 	 5)isEmpty 	 6)exit 
1
Enter value : 4

The top value is : 42 

Enter a choice : 
1)push 	 2)pop 	 3)peek  4) isFull 	 5)isEmpty 	 6)exit 
1
Enter value : 46

The top value is : 46 

Enter a choice : 
1)push 	 2)pop 	 3)peek  4) isFull 	 5)isEmpty 	 6)exit 
3
The peek value is : 46 

Enter a choice : 
1)push 	 2)pop 	 3)peek  4) isFull 	 5)isEmpty 	 6)exit 
2
The pop value is : 42 

Enter a choice : 
1)push 	 2)pop 	 3)peek  4) isFull 	 5)isEmpty 	 6)exit 
4
stack has space now

Enter a choice : 
1)push 	 2)pop 	 3)peek  4) isFull 	 5)isEmpty 	 6)exit 
6 
</pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 2. CREATE A STACK IMPLEMENTING THE OPERATIONS ON THE CHARACTERS ARRAY (PUSH, POP, PEEK,
              ISEMPTY,ISFULL)</h2>
            <pre>

  #include < stdlib.h >
  #define MAX 20
  #include < stdio.h >
 char stack[MAX];
 int top = -1;
 
 int isEmpty(){
   if (top == -1){
      return 1;
   }
   return 0;
 }
 
 int isFull(){
   if (top == MAX){
     return 1; // true
   }
     return 0;
 }
 int push (char item){
   if (isFull()){
     return -1;
   }
     top++;
     printf("Enter value : ");
     scanf("%s", &item);
     stack[top] = item;
     return top;
 }
 char pop(){
   if (isEmpty()){
     return -1;
   }
     top--;
     char data = top;
     return data;
 }
 
 char peek(){
   if (isEmpty()){
     return -1;
   }
   return top;
 }
 
 void main(){
   char item;
   int op, i;
 
   while (1){
     printf("Enter a choice : \n");
     printf("1)push \t 2)pop \t 3)peek  4) isFull \t 5)isEmpty \t 6)exit \n");
     scanf("%d", &op);
 
     switch (op){
 
     case 1:
       top = push(item);
       if (top == MAX){
         printf("stack is full : ");
       } else printf("The top value is : %c \n", stack[top]);
       break;
     case 2:
       top = pop();
       if (top == -1){
         printf("The stack is empty :\n");
       }
      else printf("The pop value is : %c \n", stack[top]);
       break;
 
     case 3:
       top = peek();
       if (top == -1){
         printf("The stack is empty :\n ");
       }
       else printf("The peek value is : %c \n", stack[top]);
         break;
       case 4:
        top = isFull();
        if(top == 1){
            printf("stack is full\n");
        }else printf("stack is not full\n");
         break;
       case 5:
         top = isEmpty();
         if(top == 1){
            printf("stack is empty\n");
        }else printf("stack is not empty\n");
         break;
       case 6:
         exit(0);
 
       default:
         printf("Invalid choice\n");
       }
     }
   }
  </pre>
          </div>

          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
    1)push 	 2)pop 	 3)peek  4) isFull 	 5)isEmpty 	 6)exit 
    Enter a choice : 
    Enter value : a

    The top value is : a 

    Enter a choice : 
    1)push 	 2)pop 	 3)peek  4) isFull 	 5)isEmpty 	 6)exit 
    1
    Enter value : b

    The top value is : b 

    Enter a choice : 
    1)push 	 2)pop 	 3)peek  4) isFull 	 5)isEmpty 	 6)exit 
    3
    The peek value is : b 

    Enter a choice : 
    1)push 	 2)pop 	 3)peek  4) isFull 	 5)isEmpty 	 6)exit 
    2
    The pop value is : a 

    Enter a choice : 
    1)push 	 2)pop 	 3)peek  4) isFull 	 5)isEmpty 	 6)exit
 </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 3. CREATE A STACK IMPLEMENTING THE OPERATIONS ON AN INTEGER NODES (DYNAMICALLY) (PUSH, POP, PEEK,
              ISEMPTY, ISFULL)</h2>
            <pre>

 #include< stdio.h>
 #include< stdlib.h >
              
 struct stack{
       int data;
       struct stack *next;
 };

  struct stack *top = NULL;
  int size = 0;

  void push(int val){

       if(top == NULL){
       //first time insert
       top = (struct stack*)malloc(sizeof(struct stack));
       top->data = val;
       top->next = NULL;
       size++;
       return;
     }

  struct stack *newNode = (struct stack*)malloc(sizeof(struct stack));
  if(newNode != NULL){
       newNode->data = val;
       newNode->next = top;
       top = newNode;
       size++;
       return;
 }
 else  printf("Stack is Full \n");
}

int pop(){

    if(top == NULL){
           return -1;
     }
      int item = top->data;
      struct stack *temp = top;
      top = top->next;
      free(temp);
      return item;
 }

  int isEmpty(){
  if(top == NULL) return 1;
      return 0;
 }
 
  int peek(){
     if(isEmpty()) return -1;
      return top->data;
 }

  int main(){
     int item;
     int op,topp;

     while (1){
       printf("Enter a choice : \n");
      printf("1)push \t 2)pop \t 3)peek  \t 4)isEmpty \t 5)exit \n");
      scanf("%d", &op);

      switch (op){

       case 1:
       printf("Enter value : ");
      scanf("%d", &item);
        push(item);
        break;

      case 2:
        topp = pop();
        if(top != -1){
             printf("the pop val is %d\n",topp);
       }else printf("stack is empty\n");
        break;

      case 3:
       topp =  peek();
        if(top != -1){
             printf("the peek val is %d\n",topp);
       }else printf("stack is empty\n");
        break;

      case 4:
        topp =  isEmpty();
        if(topp == 1){
            printf("stack is empty \n");
       }else printf("stack is not empty \n");
        break;

      case 5:
      exit(0);
        break;

      default:
        printf("Invalid choice\n");
     }
   }
 }
 </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
  Enter a choice : 
  1)push 	 2)pop 	 3)peek  	 4)isEmpty 	 5)exit 
  1
  Enter value 
  Enter a choice : 
  1)push 	 2)pop 	 3)peek  	 4)isEmpty 	 5)exit 
  2
  the pop val i
  Enter a choice : 
  1)push 	 2)pop 	 3)peek  	 4)isEmpty 	 5)exit 
  2
  the pop val i
  Enter a choice : 
  1)push 	 2)pop 	 3)peek  	 4)isEmpty 	 5)exit 
  1
  Enter value
  Enter a choice : 
  1)push 	 2)pop 	 3)peek  	 4)isEmpty 	 5)exit 
  3
  the peek val 
  Enter a choice : 
  1)push 	 2)pop 	 3)peek  	 4)isEmpty 	 5)exit 
  4
  stack is not empty
  Enter a choice : 
  1)push 	 2)pop 	 3)peek  	 4)isEmpty 	 5)exit 
  5
</pre>
          </div>
        </div>

        <div class="question">
          <div class="solve">
            <h2>Ques 4. CREATE A STACK IMPLEMENTING THE OPERATIONS ON THE CHARACTERS NODES (DYNAMICALLY) (PUSH,
              POP,PEEK,
              ISEMPTY, ISFULL)</h2>
            <pre>

#include< stdio.h>
#include< stdlib.h>
              
struct stack{
    char data;
    struct stack *next;
};

struct stack *top = NULL;
int size = 0;

void push(char val){

    if(top == NULL){
    //first time insert
    top = (struct stack*)malloc(sizeof(struct stack));
    top->data = val;
    top->next = NULL;
    size++;
    return;
    }

struct stack *newNode = (struct stack*)malloc(sizeof(struct stack));
if(newNode != NULL){
    newNode->data = val;
    newNode->next = top;
    top = newNode;
    size++;
    return;
}else printf("Stack is Full \n");

}

char pop(){

    if(top == NULL){
        return '#';
    }
    char  item = top->data;
    struct stack *temp = top;
    top = top->next;
    free(temp);
    return item;
}

int isEmpty(){
    if(top == NULL) return 1;
    return 0;
}

char peek(){
  if(isEmpty())return '#';

    return top->data;
}

int main(){
  int item;
  int op;
  char topp;

  while (1){
    printf("Enter a choice : \n");
    printf("1)push \t 2)pop \t 3)peek  \t 4)isEmpty \t 5)exit \n");
    scanf("%d", &op);

    switch (op){

    case 1:
    printf("Enter value : ");
    scanf("%s", &item);
      push(item);
      break;

    case 2:
      topp = pop();
      if(top != '#'){
          printf("the pop val is %c\n",topp);
      }else printf("stack is empty\n");
      break;

    case 3:
     topp =  peek();
      if(top != '#'){
          printf("the peek val is %c\n",topp);
      }else printf("stack is empty\n");
      break;

    case 4:
      topp =  isEmpty();
      if(topp == 1){
         printf("stack is empty \n");
      }else printf("stack is not empty \n");
      break;

    case 5:
    exit(0);
      break;

    default:
      printf("Invalid choice\n");
    }
  }
}
</pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
Enter a choice : 
1)push 	 2)pop 	 3)peek  	 4)isEmpty 	 5)exit 
1

Enter value : a

Enter a choice : 
1)push 	 2)pop 	 3)peek  	 4)isEmpty 	 5)exit 
1

Enter value : b

Enter a choice : 
1)push 	 2)pop 	 3)peek  	 4)isEmpty 	 5)exit 
1

Enter value : c

Enter a choice : 

1)push 	 2)pop 	 3)peek  	 4)isEmpty 	 5)exit 
3

the peek val is c
Enter a choice : 
1)push 	 2)pop 	 3)peek  	 4)isEmpty 	 5)exit 
2

the pop val is c

Enter a choice : 
1)push 	 2)pop 	 3)peek  	 4)isEmpty 	 5)exit 
4

stack is not empty 

Enter a choice : 
1)push 	 2)pop 	 3)peek  	 4)isEmpty 	 5)exit 
5
</pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 5. ENTER THE STRING FROM THE USER AND REVERSE THE STRING USING STACKS.</h2>
            <pre>

#include< stdio.h>
#include< stdlib.h>
#include< string.h>

struct stack{
    char data;
    struct stack *next;
};

struct stack *top = NULL;
int size = 0;

void push(char val){

    if(top == NULL){
    //first time insert
    top = (struct stack*)malloc(sizeof(struct stack));
    top->data = val;
    top->next = NULL;
    size++;
    return;
    }

struct stack *newNode = (struct stack*)malloc(sizeof(struct stack));
if(newNode != NULL){
    newNode->data = val;
    newNode->next = top;
    top = newNode;
    size++;
    return;
}
else printf("Stack is Full \n");

}

char pop(){
    if(top == NULL){
        return '#';
    }
    char  item = top->data;
    struct stack *temp = top;
    top = top->next;
    free(temp);
    return item;
}

int isEmpty(){
    if(top == NULL){
        return 1;
    }
    return 0;
}

char peek(){
  if(isEmpty()){
        return '#';
    }
    return top->data;
}

void reverseString(char str[]){
  int i;
  printf("Enter the string : \n");
  gets(str);
  
  for (i = 0; i < strlen(str); i++){
    push(str[i]);
  }
  for (i = 0; i < strlen(str); i++){
    str[i] = pop();
  }
  printf("Reversed string is : ");
  puts(str);
}

int main(){
  char str[20];
  reverseString(str);
  return 0;
}

            
</pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>

Enter the string : 

i love coding

Reversed string is : gnidoc evol i
          
</pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>6. CREATE THE PROGRAM TO MATCH THE SINGLE BRACKET USING STACKS.</h2>
            <pre>

#include< stdio.h>
#include< stdlib.h>
#include < string.h>

int size = 10;
char stack[10];

int top = -1;

char push(char item){
  if (top == size - 1){
    return size;
  }
  top++;
  stack[top] = item;
  return top;
}

char pop(){
  if (top == -1){
    return -1;
  }
  char data = stack[top];
  top--;
  return data;
}

char peek(){
  if (top == -1) {
    return -1;
  }
  return top;
}

void Bracket(char str[]){
   int i;
   for ( i = 0; i < strlen(str); i++){
    if (str[i] == '('){
      top = push(str[i]);
      if (top == size){
        printf("Stack Is Full !");
        top = size - 1;
      }
    }
    else if (str[i] == ')'){
      if (top == -1)
        break;
         pop();
    }
  }

  if (top < 0 && i == strlen(str)){
    printf("Bracket is matching.");
  }
  else printf("Bracket is not matching.");
}

void main(){
 char str[20]; 
 printf("Enter a bracket string :\n ");
 gets(str);
 Bracket(str);
}
      </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
  Enter a bracket string :

  ((()))

  Bracket is matching.
  </pre>
          </div>
        </div>

        <div class="question">
          <div class="solve">
            <h2>Ques 7. CREATE TWO INTEGER STACKS IN A SINGLE ARRAY.</h2>
            <pre>

#include < stdio.h >
#define MAX 10
              
 int stack[MAX];
 int top1 = -1;
 int top2 = MAX;
 int size = 0;
 
 // Implement 2 stack using an array
 int isEmpty(){
     if(size == 0) return 1;
     return 0;
 }
 int isFull(){
     if(size == MAX) return 1;
     return 0;
 }
 void push(int val,int stNum){
     if(isFull()){
         printf("Stack is Full!");
         return;
     }
     if(stNum == 1){
         stack[++top1] = val;
     }else if(stNum == 2){
         stack[--top2] = val;
     }else {
         printf("Enter valid stack no.!");
     }
     size++;
     return;
 }
 int pop(int stNum){
     if(isEmpty()){
         printf("Stack is Empty!");
         return _INT_MAX_;
     }
     int data;
     if(stNum == 1){
         data = stack[top1--];
     }else if(stNum == 2){
         data = stack[top2++];
     }else {
         printf("Enter valid stack no.!");
     }
     size--;
     return data;
 }
 int peek(int stNum){
     if(isEmpty()){
         printf("Stack is Empty!");
         return _INT_MAX_;
     }
     if(stNum == 1){
         return stack[top1];
     }else if(stNum == 2){
         return stack[top2];
     }else {
         printf("Enter valid stack no.!");
     }
 }
 
 
 void main(){
     push(10,1);
     push(20,1);
     push(50,2);
     push(60,2);
     printf("%d ",peek(1));
     printf("%d ",peek(2));
 }
</pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
20 60
</pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 8. SORT THE STACK IN ASCENDING ORDER USING INTEGER ARRAY.</h2>
            <pre>

              #include < stdio.h>
              #include < stdlib.h>
              #define MAX 5
              int stack[5];

              int top = -1;

              int isEmpty(){
                  if (top == -1){
                  return 1;
              }
              return 0;
              }
              
              int isFull(){
                  if (top == MAX){
                  return 1; // true
              }
              else
              return 0;
              }


              int push(int item){
              if (isFull()){
              return -1;
              }
              
              top++;
              stack[top] = item;
              return top;
              }

              int pop(){
              if (isEmpty()){
              return -1;
              }
              top--;
              return top;
              }
              
              
              int peek(){
              if (isEmpty()){
              return -1;
              }
              return top;
              }
              
              
              
              void bubbleSort(int row, int col, int arr[], int n){
                if (row > n - 2)
                  return;
                if (col > n - 2 - row)
                  bubbleSort(row + 1, 0, arr, n);
                else{
                  if (arr[col] > arr[col + 1]){
                    int temp = arr[col];
                    arr[col] = arr[col + 1];
                    arr[col + 1] = temp;
                  }
                  bubbleSort(row, col + 1, arr, n);
                }
              }
              // Sort the stack using recursion.
              
              int main(){
                push(4);
                push(2);
                push(1);
                push(3);
                push(6);

                bubbleSort(0, 0, stack, MAX);
              
                printf("stack element in ascending order : ");

                for (int i = 0; i < MAX; i++){
                  printf("%d\t", stack[i]);
                }
                return 0;
              }
            </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
            stack element in ascending order  : 1	2	3	4	6	
      </pre>
          </div>
        </div>

        <div class="question">
          <div class="solve">
            <h2>Ques 9. ENTER THE INFIX EXPRESSION FROM USER AND CONVERT INTO PREFIX EXPRESSION.</h2>
            <pre>

#include < stdio.h>
#include < stdlib.h>
#include < string.h>
#define SI
    struct Node{
        char data;
        struct Node *next;
    };
    
    struct Node *top = NULL;
    
    void push(char val){
        if(top == NULL){
            top = (struct Node*)malloc(sizeof(struct Node));
            top->data = val;
            top->next = NULL;
            return;
        }
        
        struct Node *temp  = (struct Node*)malloc(sizeof(struct Node));
        if(temp == NULL){
            printf("Stack is Full!");
            return;
        }
        temp->data = val;
        temp->next = top;
        top = temp;
    }
    
    char pop(){
        if(top == NULL){
            printf("Stack is Empty!");
            return '#';
        }
        int item = top->data;
        struct Node *temp = top;
        top = top->next;
        free(temp);
        return item;
    }
    
    char peek(){
        if(top == NULL){
        return '#';
        }
        return top->data;
    }
    
    int precedence(char ch){
        switch(ch){
            case '#':
            return 0;
            case '+':
            case '-':
            return 1;
            case '*':
            case '/':
            return 2;
            case '^':
            return 3;
        }
    }
    
    int isOperator(char ch){
        if(ch == '+' || ch == '-' || ch == '/' || ch == '*' || ch == '^'){
            return 1;
        }
        return 0;
    }
    
    
    void infixToPostfix(char infix[],char postfix[]){
        int j = 0;
        push('#');
        for(int i = 0;i < strlen(infix);i++){
            char ch = infix[i];
            if(isOperator(ch)==0){
                postfix[j++] = ch;
            }
            else {
                if(ch == '(') {
                    push(ch);
                }
                else if(ch == ')'){
                    while( peek() != '('){
                        postfix[j++] = pop();
                    }
                    pop();
                }
                else {
                    if(precedence(ch) > precedence(peek())){
                       push(ch);
                    }
                    else {
                        while(precedence(ch) <= precedence(peek())){
                            postfix[j++] = pop();
                        }
                        push(ch);
                    }
                }
            }
        }
    
        while(peek() != '#'){
            postfix[j++] = pop();
        }
        pop();
        postfix[j] = '\0';
    
    
    }

    // Reverse a string using stack.
    void reverseString(char str[]){
        int i = 0;
        push('#');
        while(i < strlen(str)){
            push(str[i]);
            i++;
        }
        i = 0;
        while(peek() != '#'){
            str[i] = pop();
            i++;
        }
        pop();
    }
    // Infix to Prefix.
    void infixToPrefix(char infix[],char prefix[]){
    //1. Reverse the infx expression.
    reverseString(infix);
    //2. Convert the reverse expression into postfix.
    infixToPostfix(infix,prefix);
    //3. reverse the postfix expression back.
    reverseString(prefix);
    
    }

    void main(){
        char infix[SIZE],prefix[SIZE];
        puts("Enter an expression\n");
        fgets(infix,SIZE,stdin);
        infixToPrefix(infix,prefix);
        printf("%s ",prefix);
    }
    </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
     Enter an expression
     5+6*2/5
     +5*6/25
      </pre>
          </div>
        </div>

        <div class="question">
          <div class="solve">
            <h2>Ques 10. ENTER THE INFIX EXPRESSION FROM USER AND CONVERT INTO POSTFIX EXPRESSION.</h2>
            <pre>
  #include < stdio.h>
  #include < stdlib.h>
  #include < string.h>
  #define SIZE  50
  struct Node{
      char data;
      struct Node *next;
  };
  
  struct Node *top = NULL;
  
  void push(char val){

      if(top == NULL){
          top = (struct Node*)malloc(sizeof(struct Node));
          top->data = val;
          top->next = NULL;
          return;
      }
      struct Node *temp  = (struct Node*)malloc(sizeof(struct Node));
      if(temp == NULL){
          printf("Stack is Full!");
          return;
      }
      temp->data = val;
      temp->next = top;
      top = temp;
  }
  
  char pop(){
      if(top == NULL){
          printf("Stack is Empty!");
          return '#';
      }
      int item = top->data;
      struct Node *temp = top;
      top = top->next;
      free(temp);
      return item;
  }
  
  char peek(){
      if(top == NULL){
      return '#';
      }
      return top->data;
  }
  
  int precedence(char ch){
      switch(ch){
          case '#':
          return 0;
          case '+':
          case '-':
          return 1;
          case '*':
          case '/':
          return 2;
          case '^':
          return 3;
      }
  }
  
  int isOperator(char ch){
      if(ch == '+' || ch == '-' || ch == '/' || ch == '*' || ch == '^'){
          return 1;
      }
      return 0;
  }
  
  
  void infixToPostfix(char infix[],char postfix[]){
      int j = 0;
      push('#');
      for(int i = 0;i < strlen(infix);i++){
          char ch = infix[i];

          if(isOperator(ch)==0){
              postfix[j++] = ch;
          }
          else {
              if(ch == '(') {
                  push(ch);
              }
              else if(ch == ')'){
                  while(peek() != '('){
                      postfix[j++] = pop();
                  }
                  pop();
              }
              else {
                  if(precedence(ch) > precedence(peek())){
                     push(ch);
                  }
                  else {
                      while(precedence(ch) <= precedence(peek())){
                          postfix[j++] = pop();
                      }
                      push(ch);
                  }
              }
          }
      }
  
      while(peek() != '#'){
          postfix[j++] = pop();
      }
      pop();
      postfix[j] = '\0';
  
  
  }
  
  void main(){
     char infix[SIZE],postfix[SIZE];
     puts("Enter expression");
     fgets(infix,SIZE,stdin);
      infixToPostfix(infix,postfix);
      printf("%s ",postfix);
  }
    </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
            Enter expression
            5+6*2/5-8+6
            562*5/+8-6+
      </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 11. CREATE A PROGRAM TO EVALUATE THE PREFIX EXPRESSION.</h2>
            <pre>
   #include < stdio.h>
   #include < stdlib.h>
   #include < string.h>
   #include < math.h>
   #define SIZE  20
   
   struct Node{
       int data;
       struct Node *next;
   };
   
   struct Node *top = NULL;
   
   void push(char val){
       if(top == NULL){
           top = (struct Node*)malloc(sizeof(struct Node));
           top->data = val;
           top->next = NULL;
           return;
       }
       struct Node *temp  = (struct Node*)malloc(sizeof(struct Node));
       if(temp == NULL){
           printf("Stack is Full!");
           return;
       }
       temp->data = val;
       temp->next = top;
       top = temp;
   }
   
   int pop(){
       if(top == NULL){
           printf("Stack is Empty!");
           return 0;
       }
       int item = top->data;
       struct Node *temp = top;
       top = top->next;
       free(temp);
       return item;
   }
   
   char peek(){
       if(top == NULL){
       return 0;
       }
       return top->data;
   }
   
   int precedence(char ch){
       switch(ch){
           case '#':
           return 0;
           case '+':
           case '-':
           return 1;
           case '*':
           case '/':
           return 2;
           case '^':
           return 3;
       }
   }
   
   int isOperator(char ch){
       if(ch == '+' || ch == '-' || ch == '/' || ch == '*' || ch == '^'){
           return 1;
       }
       return 0;
   }
   
   int evaluate(int op1,int op2,char operator){
       switch(operator){
           case '+':
           return op1+op2;
           case '-':
           return op1-op2;
           case '*':
           return op1*op2;
           case '/':
           return op1/op2;
           case '%':
           return op1%op2;
           case '^':
           return (int)pow(op1,op2);
       }
   }
   
   int reducePrefix(char prefix[]){
     int i = strlen(prefix) - 1;
      while(i >= 0){
        char ch = prefix[i];
       if(ch == '\n') {
           i--;
       }
       else if(isOperator(ch) == 0){
           push(ch - '0');
           i--;
       }else {
           int op1 = pop();
           int op2 = pop();
           int n = evaluate(op1,op2,ch);
           push(n);
       i--;
       }
      }
      return pop();
     }
              
  void main(){

      char prefix[SIZE];
      puts("Enter an expression");
      fgets(prefix,SIZE,stdin);
      int ans = reducePrefix(prefix);
      printf("\nAnswer is : %d",ans);
  }
          </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
            Enter an expression
            /+552
            Answer is : 5
      </pre>
          </div>
        </div>
        <div class="question">
          <div class="solve">
            <h2>Ques 12. CREATE A PROGRAM TO EVALUATE THE POSTFIX EXPRESSION.</h2>
            <pre>

#include < stdio.h>
#include < stdlib.h>
#include < string.h>
#include < math.h>
#define SIZE  20

struct Node{
    int data;
    struct Node *next;
};

struct Node *top = NULL;

void push(char val){
    if(top == NULL){
        top = (struct Node*)malloc(sizeof(struct Node));
        top->data = val;
        top->next = NULL;
        return;
    }
    struct Node *temp  = (struct Node*)malloc(sizeof(struct Node));
    if(temp == NULL){
        printf("Stack is Full!");
        return;
    }
    temp->data = val;
    temp->next = top;
    top = temp;
}

int pop(){
    if(top == NULL){
        printf("Stack is Empty!");
        return 0;
    }
    int item = top->data;
    struct Node *temp = top;
    top = top->next;
    free(temp);
    return item;
}

char peek(){
    if(top == NULL){
    return 0;
    }
    return top->data;
}

int precedence(char ch){
    switch(ch){
        case '#':
        return 0;
        case '+':
        case '-':
        return 1;
        case '*':
        case '/':
        return 2;
        case '^':
        return 3;
    }
}

int isOperator(char ch){
    if(ch == '+' || ch == '-' || ch == '/' || ch == '*' || ch == '^'){
        return 1;
    }
    return 0;
}

int evaluate(int op1,int op2,char operator){
    switch(operator){
        case '+':
        return op1+op2;
        case '-':
        return op1-op2;
        case '*':
        return op1*op2;
        case '/':
        return op1/op2;
        case '%':
        return op1%op2;
        case '^':
        return (int)pow(op1,op2);
    }
}

int reducePostfix(char postfix[]){
  int i = 0;
  while(postfix[i]){
    char ch = postfix[i];
    if(ch == '\n') {
        i++;
        continue;
    }
    if(isOperator(ch) == 0){
        push(ch - '0');
    }else {
        int op2 = pop();
        int op1 = pop();
        int n = evaluate(op1,op2,ch);
        push(n);
    }
    i++;
  }
   return pop();
}

void main(){
    char postfix[SIZE];
    puts("Enter an expression");
    fgets(postfix,SIZE,stdin);
    int ans = reducePostfix(postfix);
    printf("\nAnswer is : %d",ans);
}  
    </pre>
          </div>
          <div class="output">
            <h1>OUTPUT</h1>
            <pre>
            Enter an expression
            12-6+2
            Answer is : 2
      </pre>
          </div>
        </div>
        <!--**********************************QUEUE******************************************************-->
        <section id="Queue">
          <h1>Queue</h1>
          <div class="question">
            <div class="solve">
              <h2>Ques 1. IMPLEMENT THE OPERATIONS OF SIMPLE QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY,
                ISFULL)
              </h2>
              <pre>

#include < stdio.h>
#define max 20
int Queue[max];
int front = -1;
int rear = -1;
int size = 0;

void push(int val){
  if (rear == max){
    printf("Queue is full \n");
    }
  if (rear == -1 && front == -1){
    rear = front = 0;
    Queue[rear] = val;
    size++;
  }
  else{
    rear++;
    Queue[rear] = val;
    size++;
  }
}

int pop(){
  if (front == -1){
    return -1;
  }
  int val;
  // first time
  if (front == 0 && rear == 0){
    val = Queue[front];
    rear = front = -1;
  }
  else{
   val = Queue[front];
    for (int i = front; i < rear; i++){
      Queue[i] = Queue[i + 1];
      rear--;
      size--;
    }
  }
  return val;
}

int peek(){
  if (front == -1){
    return -1;
  }
  return Queue[front];
}
void display(){
  for (int i = front; i <= rear; i++){
    printf("%d\t", Queue[i]);
  }
}

int main(){
  int item, op, i;

  while (1){
    printf("Enter a choice : \n");
    printf("1)push \t 2)pop \t 3)peek  4) display \t 5)exit \n");
    scanf("%d", &op);

    switch (op){

    case 1:
      int value;
      printf("Enter a value : ");
      scanf("%d", &value);
      push(value);
      break;

    case 2:
      item = pop();
      if (item != -1){
        printf("pop value is : %d\n ", item);
      }
      else{
        printf("Queue is empty");
      }
      break;

    case 3:
      int val = peek();
      if (val != -1){
        printf("peek value is : %d\n ", val);
      }
      else{
        printf("Queue is empty");
      }
      break;

    case 4:
      display();
      break;

    case 5:
      exit(0);
    default:
      printf("Invalid choice\n");
    }
  }

  return 0;
}
</pre>
            </div>
            <div class="output">
              <h1>OUTPUT</h1>
              <pre>


    Enter a choice : 
    1)push 	 2)pop 	 3)peek  4) display 	 5)exit 
    1

    Enter a value : 25

    Enter a choice : 
    1)push 	 2)pop 	 3)peek  4) display 	 5)exit 
    1

    Enter a value : 26

    Enter a choice : 
    1)push 	 2)pop 	 3)peek  4) display 	 5)exit 
    4
    25	26	

    Enter a choice : 

    1)push 	 2)pop 	 3)peek  4) display 	 5)exit 
    2

    pop value is : 25
    Enter a choice : 

    1)push 	 2)pop 	 3)peek  4) display 	 5)exit 
    2

    pop value is : 26
    Enter a choice : 

    1)push 	 2)pop 	 3)peek  4) display 	 5)exit 
    2

    Queue is empty : 
    Enter a choice : 
    1)push 	 2)pop 	 3)peek  4) display 	 5)exit
    5
            </pre>
            </div>
          </div>
          <div class="question">
            <div class="solve">
              <h2>Ques 2.1 IMPLEMENT THE OPERATIONS OF SIMPLE QUEUE IN AN character (INSERT, DELETE, PEEK, ISEMPTY,
                ISFULL)
              </h2>
              <pre>
                #include <stdio.h>
                  #define max 20
                  char Queue[max];
                  int front = -1;
                  int rear = -1;
                  int size = 0;
                  
                  void push(char val){
                    if (rear == max){
                      printf("Queue is full \n");
                    }
                    if (rear == -1 && front == -1){
                      rear = front = 0;
                      Queue[rear] = val;
                      size++;
                    }
                    else{
                      rear++;
                      Queue[rear] = val;
                      size++;
                    }
                  }
                  char pop(){
                    if (front == -1){
                    printf("Queue is empty \n");
                    }
                    int val;
                    // first time
                    if (front == 0 && rear == 0){
                      val = Queue[front];
                      rear = front = -1;
                    }
                    else{
                      val = Queue[front];
                      for (int i = front; i < rear; i++){
                        Queue[i] = Queue[i + 1];
                        rear--;
                        size--;
                      }
                    }
                    return val;
                  }
                  char peek(){
                    if (front == -1){
                      printf("Queue is empty \n");
                    }
                    return Queue[front];
                  }
                  void display(){
                    for (int i = front; i <= rear; i++){
                      printf("%c\t", Queue[i]);
                    }
                  }
                  int main(){
                    int  op, i;
                  
                    while (1){
                      printf("Enter a choice : \n");
                      printf("1)push \t 2)pop \t 3)peek  4) display \t 5)exit \n");
                      scanf("%d", &op);
                  
                      switch (op)
                      {
                  
                      case 1:
                        char value;
                        printf("Enter a value : ");
                        scanf("%s", &value);
                        push(value);
                        break;
                      case 2:
                        char item = pop();
                        if (item != -1)
                        {
                          printf("pop value is : %c\n ", item);
                        }
                        else{
                          printf("Queue is empty");
                        }
                        break;
                  
                      case 3:
                        char val = peek();
                        if (val != -1)
                        {
                          printf("peek value is : %c\n ", val);
                        }
                        else{
                          printf("Queue is empty");
                        }
                        break;
                      case 4:
                        display();
                        break;
                      case 5:
                        exit(0);
                      default:
                        printf("Invalid choice\n");
                      }
                    }
                  
                    return 0;
                  }
                  
              
            </pre>
            </div>
            <div class="output">
              <h1>OUTPUT</h1>
              <pre>
                Enter a choice : 
                1)push 	 2)pop 	 3)peek  4) display 	 5)exit 
                1
                Enter a value : a
                Enter a choice : 
                1)push 	 2)pop 	 3)peek  4) display 	 5)exit 
                1
                Enter a value : b
                Enter a choice : 
                1)push 	 2)pop 	 3)peek  4) display 	 5)exit 
                3
                peek value is : a
                 Enter a choice : 
                1)push 	 2)pop 	 3)peek  4) display 	 5)exit 
                2
                pop value is : a
                 Enter a choice : 
                1)push 	 2)pop 	 3)peek  4) display 	 5)exit 
                1
                Enter a value : c
                Enter a choice : 
                1)push 	 2)pop 	 3)peek  4) display 	 5)exit 
                4
                b	c	
                Enter a choice : 
                1)push 	 2)pop 	 3)peek  4) display 	 5)exit 
                5

              </pre>
            </div>
          </div>
          <div class="question">
            <div class="solve">
              <h2>Ques 2. IMPLEMENT THE OPERATIONS OF SIMPLE QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY,
                ISFULL)
              </h2>
              <pre>

  #include < stdio.h>
  #include < string.h>
  #define MAX 10
  int front = -1;
  int rear = -1;
  int size = 0;
  char queue[MAX][100];
  
  void enque(char str[]){
      if(size == MAX){
          printf("Queue is Full!");
          return;
      }
      size++;
      if(front == -1 && rear == -1){
          //adding first time
          front = rear = 0;
          strcpy(queue[rear],str);
          return;
      }
      rear++;
      strcpy(queue[rear],str);
  }
  
  char* deque(){
      if(size == 0) {
          printf("Queue is Empty!");
          return NULL;
      }
      char val[100];
      if(size == 1){
          strcpy(val,queue[front]);
          queue[front];
          front = rear = -1;
          return &val[0];
      }
      //shifting items towards left.
       strcpy(val,queue[front]);
      for(int i = front+1; i <= rear;i++){
          strcpy(queue[i-1],queue[i]);
      }
      rear--;
      size--;
      return &val[0];
  }
  
  void display(){
      if(size == 0) {
       printf("Queue is Empty!");
       return ;
      }
      for(int i = front; i <= rear;i++){
          printf("%s ",queue[i]);
      }
  }
  
  char* peek(){
       if(size == 0) {
          printf("Queue is Empty!");
          return NULL;
      }
      return queue[front];
  }

  int isEmpty(){
      if(size == 0) return 1;
      return 0;
  }

  int isFull(){
      if(size == MAX) return 1;
      return 0;
  }
  
  
  void main(){
      enque("Hello");
      enque("faham");
      enque("How are you ?");
      display();    
      dequeue();
      printf("\n");
      display();
  }    
                  
              
            </pre>
            </div>
            <div class="output">
              <h1>OUTPUT</h1>
              <pre>
                Hello faham How are you ? 
                faham How are you ? 

              </pre>
            </div>
          </div>
          <div class="question">
            <div class="solve">
              <h2>Ques 3. IMPLEMENT THE OPERATIONS OF QUEUE DYNAMICALLY OF INTEGERS (INSERT, DELETE, PEEK, ISEMPTY,
                ISFULL)
              </h2>
              <pre>
   #include < stdio.h>
   #include < stdlib.h>
   struct queue{
       int data;
       struct queue *next;
   };
   struct queue *front = NULL;
   struct queue *rear = NULL;
   struct queue *newNode;
   int size = 0;
   
   void enqueue(int data){
       if(size == 0){
           rear = (struct queue*)malloc(sizeof(struct queue));
           rear->data = data;
           rear->next = NULL;
           front = rear;
           size++;
           return;
       }
       newNode = (struct queue*)malloc(sizeof(struct queue));
       if(newNode != NULL){
       newNode->data = data;
       rear->next = newNode;
       rear = newNode;
       rear->next = NULL;
       size++;
       }else{
           printf("Queue is Full\n");
       }
   }
   int dequeue(){
       if(size == 0){
           return -1;
       }
       //if only one node exist in the queue
        int data = front->data;
        if(size == 1){
        front = rear = NULL;
        size = 0;
        return data;
        }
        struct queue *temp = front;
        front = front->next;
        free(temp);
        size--;
        return data;
   }
   int peek(){
       if(size == 0){
           printf("Queue is empty\n");  
       }
       return front->data;
   }
   void display(){
       struct queue *temp = front;
       while(temp != NULL){
           printf("%d->",temp->data);
           temp = temp->next;
       }
       printf("\n");
   }
   int main() {
       int choice,val;
        while(1){
       printf("Enter any choice :\n ");
       printf("1)Insert  2)delete 3)peek 4)display 5)exit \n");
       scanf("%d",&choice);
       
       switch(choice){
               case 1:
                val;
               printf("Enter an element :\n");
               scanf("%d",&val);
               enqueue(val);break;
               
               case 2:
               val = dequeue();
               if(val != -1){
                   printf("delete value is %d:\n ",val);
               }else{
                    printf("Queue is empty\n");  
               }
               break;
               case 3:
               val =  peek();
               if(val != -1){
                   printf("peek value is %d:\n ",val);
               }else{
                    printf("Queue is empty\n");  
               }
               break;
               case 4:
               display();
               break;
               case 5:
               exit(0);
               default :
               printf("Invalid choice \n");
           }
       }
       return 0;
      }
            </pre>
            </div>
            <div class="output">
              <h1>OUTPUT</h1>
              <pre>

                Enter any choice :
                 1)Insert  2)delete 3)peek 4)display 5)exit 
                1
                Enter an element :
                41
                Enter any choice :
                 1)Insert  2)delete 3)peek 4)display 5)exit 
                1
                Enter an element :
                42
                Enter any choice :
                 1)Insert  2)delete 3)peek 4)display 5)exit 
                3
                peek value is 41:
                 Enter any choice :
                 1)Insert  2)delete 3)peek 4)display 5)exit 
                2
                delete value is 41:
                 Enter any choice :
                 1)Insert  2)delete 3)peek 4)display 5)exit 
                1
                Enter an element :
                44
                Enter any choice :
                 1)Insert  2)delete 3)peek 4)display 5)exit 
                4
                42->44->
                Enter any choice :
                 1)Insert  2)delete 3)peek 4)display 5)exit 
                5
              </pre>
            </div>
          </div>
          <div class="question">
            <div class="solve">
              <h2>Ques 4. IMPLEMENT THE OPERATIONS OF QUEUE DYNAMICALLY OF STRING (INSERT, DELETE, PEEK, ISEMPTY,
                ISFULL)
              </h2>
              <pre>
                #include < stdio.h>
                  #include < stdlib.h>
                  #include < string.h>
                  
                  struct Node {
                      char data[100];
                      struct Node *next;
                  };
                  
                  struct Node *front = NULL,*rear = NULL;
                  int size = 0;
                  
                  int isEmpty(){
                      if(size == 0) return 1;
                      return 0;
                  }
                  
                  void display(){
                      struct Node *temp = front;
                      while(temp != NULL){
                          printf("%s ",temp->data);
                          temp = temp->next;
                      }
                  }
                  void add(char str[]){
                      if(rear == NULL && front == NULL){
                          rear = (struct Node*)malloc((sizeof(struct Node)));
                          strcpy(rear->data,str);
                          rear->next = NULL;
                          front = rear;
                          size++;
                          return;
                      }
                      struct Node *temp = (struct Node*)malloc((sizeof(struct Node)));
                      if(temp == NULL){
                          printf("Queue if FULL!");
                          return;
                      }
                      strcpy(temp->data,str);
                      temp->next = NULL;
                      rear->next = temp;
                      rear = temp;
                      size++;
                  }
                  
                  char* remove1(){
                      if(size == 0){
                          printf("Queue is Empty!");
                          return NULL;
                      }
                      char val[100];
                      strcpy(val,front->data);
                      struct Node *temp = front;
                      front = front->next;
                      free(temp);
                      size--;
                      return &val[0];
                  }
                  
                  char* peek(){
                      if(front == NULL){
                          printf("Queue is Empty!");
                          return NULL;
                      }
                      return &(front->data)[0]; 
                  }
                  
                  
                  
                  void main(){
                      add("hello\n");
                      add("kese \n");
                      add("hu \n");
                      add("sb \n");
                      display();
                      printf("Delete value is :%s\n",remove1());
                      printf("the top most value is : %s\n",peek());
                      display();
                      
                  }

            </pre>
            </div>
            <div class="output">
              <h1>OUTPUT</h1>
              <pre>
                hello
                kese 
                hu 
                sb 

                Delete value is :(null)
                The top most value is : kese 
               
               kese 
               hu 
               sb 
              </pre>
            </div>
          </div>
          <div class="question">
            <div class="solve">
              <h2>Ques 5. IMPLEMENT THE OPERATIONS OF CIRCULAR QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY,
                ISFULL)

              </h2>
              <pre>
                #include < stdio.h>
                #define MAX 5
                  
                  int front = -1;
                  int rear = -1;
                  int size = 0;
                  int queue[MAX];
                  
                  void enque(int val){
                      if(front == 0 && rear == MAX-1 || front == rear+1){
                          printf("Queue is Full!");
                          return;
                      }else if(rear == -1){
                          front = rear = 0;
                          size++;
                      }else rear = (rear+1)%MAX;
                      queue[rear] = val;
                      size++;
                  }
                  
                  int deque(){
                      if(front == -1){
                          printf("Queue is Empty!");
                          return -1;
                      }
                      int val = queue[front];
                      if(front == rear){
                          front = rear = -1;
                          return val;
                      }
                      front = (front+1)%MAX;
                      return val;
                  }
                  int peek(){
                      if(front == -1){
                          return -1;
                      }
                      return queue[front];
                  }
                void display1(){
                    if(size == 0)printf("Queue is Empty");
                    
                    int i = front;
                   for(i = front;i<=rear;i++){
                       printf("%d ",queue[i]);
                   }
                }
                  
                  int isFull(){
                      if(size == MAX){
                          return 1;
                      }
                      return 0;
                  }
                  
                  int isEmpty(){
                      if(size == 0) {
                          return 1;
                      }
                      return 0;
                  }
                  
                  void main(){
                      enque(10);
                      enque(20);
                      enque(30);
                      enque(40);
                      enque(50);
                      deque();
                      display1();
                  }

            </pre>
            </div>
            <div class="output">
              <h1>OUTPUT</h1>
              <pre>
                20 30 40 50 
              </pre>
            </div>
          </div>
          <div class="question">
            <div class="solve">
              <h2>Ques 6. IMPLEMENT THE OPERATIONS OF CIRCULAR QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY,
                ISFULL)
              </h2>
              <pre>
                  #include < stdio.h>
                  #include < string.h>
                  #define MAX 15
                  
                  int front = -1;
                  int rear = -1;
                  int size = 0;
                  char queue[MAX][100];
                  
                  void enque(char str[]){
                      if(front == 0 && rear == MAX-1 || front == rear+1){
                          printf("Queue is Full!");
                          return;
                      }else if(rear == -1){
                          front = rear = 0;
                          size++;
                      }else rear = (rear+1)%MAX;
                      strcpy(queue[rear],str);
                      size++;
                  }
                  
                  char* deque(){
                      if(front == -1){
                          printf("Queue is Empty!");
                          return NULL;
                      }
                      char val[100];
                       strcpy(val,queue[front]);
                      if(front == rear){
                        front = rear = -1;
                        return &val[0];
                      }
                      front = (front+1)%MAX;
                      return &val[0];
                  }
                  char* peek(){
                      if(front == -1){
                          return NULL;
                      }
                      return queue[front];
                  }
                  
                  void display1(){
                      if(size==0)printf("Queue is Empty !");
                      int i = front;
                      for(int i = front;i <= rear;i++){
                          printf(" %s",queue[i]);
                      }
                  }
                  
                  int isFull(){
                      if(size == MAX){
                          return 1;
                      }
                      return 0;
                  }
                  
                  int isEmpty(){
                      if(size == 0) {
                          return 1;
                      }
                      return 0;
                  }
                  
                  void main(){
                      enque("if");
                      enque("code");
                      enque("is ");
                      enque("not");
                      enque("run");
                      enque(" order coffee :) ");
                      display1();
                      deque();
                      printf("\n");
                      display1();
                  }

            </pre>
            </div>
            <div class="output">
              <h1>OUTPUT</h1>
              <pre>
                if code is  not run order coffee :)
                code is  not run order coffee :)
              </pre>
            </div>
          </div>
          <div class="question">
            <div class="solve">
              <h2>Ques 7. IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK, ISEMPTY,
                ISFULL)
              </h2>
              <pre>

#include < stdio.h>
  #define MAX 10
      int size = 0;
      int queue[MAX];
      int priority[MAX];
      
      void rightShift(int index){
          for(int j = size - 1;j >= index;j--){
              queue[j+1] = queue[j];
          }
          for(int j = size-1;j >= index;j--){
              priority[j+1] = priority[j];
          }
      }
      int isEmpty(){
          if(size == 0) return 1;
          return 0;
      }
      int isFull(){
          if(size == MAX) return 1;
          return 0;
      }
      void add(int val,int pri){
          if(size >= MAX ){
              printf("Queue is Full!");
              return;
          }
          if(size == 0){
              queue[0] = val;
              priority[0] = pri;
              size++;
              return;
          }
          for(int j = 0;j < MAX;j++){
              if(priority[j] > pri){
                  rightShift(j);
                  queue[j] = val;
                  priority[j] = pri;
                  break;
              }else {
                  // empty slot.
                  if(priority[j] == -1){
                      queue[j] = val;
                      priority[j] = pri;
                      break;
                  }
              }
          }
          size++;
          return;
      }
      void leftShift(){
          for(int i = 1;i < size;i++){
              queue[i-1] = queue[i];
              priority[i-1] = priority[i];
          }
      }
      int delete(){
          if(size == 0){
              printf("Queue is Empty!");
              return -1;
          }
          int val = queue[0];
          leftShift();
          size--;
          return val;
      }
      int peek(){
          if(size == 0){
              printf("Queue is Empty!");
              return -1;
          }
          return queue[0];
      }
      void display(){
          for(int i = 0;i < MAX;i++) printf("%d ",queue[i]);
          printf("\n");
      }
      
      void main(){
          for(int i = 0;i < MAX;i++){
          priority[i] = -1;
          }
          add(10,5);
          add(20,7);
          add(30,8);
          add(40,2);
          add(50,3);
          add(60,1);
          add(70,0);
          add(80,4);
          display();
          printf("\n");
          delete();
          display();
          printf("\n");
          delete();
          display();
          printf("\n");
          delete();
          display();
      }

            </pre>
            </div>
            <div class="output">
              <h1>OUTPUT</h1>
              <pre>
                70 60 40 50 80 10 20 30 0 0 

                60 40 50 80 10 20 30 30 0 0 
                
                40 50 80 10 20 30 30 30 0 0 
                
                50 80 10 20 30 30 30 30 0 0 
              </pre>
            </div>
          </div>
          <div class="question">
            <div class="solve">
              <h2>Ques 8. IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK, ISEMPTY,
                ISFULL)
              </h2>
              <pre>

    #include <stdio.h>
      #include <string.h>
      #define MAX 10
      int size = 0;
      char queue[MAX][100];
      int priority[MAX];
      
      void rightShift(int index){
          for(int j = size - 1;j >= index;j--){
              strcpy(queue[j+1],queue[j]);
          }
          for(int j = size-1;j >= index;j--){
              priority[j+1] = priority[j];
          }
      }
      int isEmpty(){
          if(size == 0) return 1;
          return 0;
      }
      int isFull(){
          if(size == MAX) return 1;
          return 0;
      }
      void add(char val[],int pri){
          if(size >= MAX ){
              printf("Queue is Full!");
              return;
          }
          if(size == 0){
              strcpy(queue[0],val);
              priority[0] = pri;
              size++;
              return;
          }
          for(int j = 0;j < MAX;j++){
              if(priority[j] > pri){
                  rightShift(j);
                   strcpy(queue[j],val);
                  priority[j] = pri;
                  break;
              }else {
                  // empty slot.
                  if(priority[j] == -1){
                      strcpy(queue[j],val);
                      priority[j] = pri;
                      break;
                  }
              }
          }
          size++;
          return;
      }
      void leftShift(){
          for(int i = 1;i < size;i++){
             strcpy(queue[i-1],queue[i]);
              priority[i-1] = priority[i];
          }
      }
      char* delete(){
          if(size == 0){
              printf("Queue is Empty!");
              return NULL;
          }
          char *val = queue[0];
          leftShift();
          size--;
          return val;
      }
      char* peek(){
          if(size == 0){
              printf("Queue is Empty!");
              return NULL;
          }
          return queue[0];
      }
      void display(){
          for(int i = 0;i < size;i++) printf("%s ",queue[i]);
          printf("\n");
      }
      
      void main(){
          for(int i = 0;i < MAX;i++){
          priority[i] = -1;
          }
          add("by",40);
          add("faiz",30);
          add("hi",1);
          add("hmm,",0);
          display();
          printf("The remove val is : %s\n",delete());
          display();
      }               

            </pre>
            </div>
            <div class="output">
              <h1>OUTPUT</h1>
              <pre>
                hmm, hi faiz by 
                The remove val is : hi
                hi faiz by 
              </pre>
            </div>
          </div>
          <div class="question">
            <div class="solve">
              <h2>Ques 9. IMPLEMENT THE OPERATIONS OF DOUBLE ENDED QUEUE IN AN INTEGER ARRAY (INSERT, DELETE, PEEK,
                ISEMPTY, ISFULL)
              </h2>
              <pre>
    #include < stdio.h>
    #include < stdlib.h>
    
    #define MAX_SIZE 10
    
    int deque[MAX_SIZE];
    int front = -1, rear = -1;
    
    // Function to check if the Deque is empty
    int is_empt() {
        return front == -1;
    }
    
    // Function to check if the Deque is full
    int is_full() {
        return ((front == 0 && rear == MAX_SIZE - 1) || (rear == front - 1));
    }
    
    // Function to insert an element at the front of the Deque
    void insert_at_front(int value) {
        if (is_full()) {
            printf("Deque is full. Cannot insert at the front.\n");
        } else {
            if (front == -1) {
                front = rear = 0;
            } else if (front == 0) {
                front = MAX_SIZE - 1;
            } else {
                front--;
            }
            deque[front] = value;
            printf("Inserted at the front: %d\n", value);
        }
    }
    
    // Function to insert an element at the rear of the Deque
    void insert_at_rear(int value) {
        if (is_full()) {
            printf("Deque is full. Cannot insert at the rear.\n");
        } else {
            if (front == -1) {
                front = rear = 0;
            } else if (rear == MAX_SIZE - 1) {
                rear = 0;
            } else {
                rear++;
            }
            deque[rear] = value;
            printf("Inserted at the rear: %d\n", value);
        }
    }
    
    // Function to delete an element from the front of the Deque
    void delete_from_front() {
        if (is_empt()) {
            printf("Deque is empty. Cannot delete from the front.\n");
        } else {
            printf("Deleted from the front: %d\n", deque[front]);
            if (front == rear) {
                front = rear = -1;
            } else if (front == MAX_SIZE - 1) {
                front = 0;
            } else {
                front++;
            }
        }
    }
    
    // Function to delete an element from the rear of the Deque
    void delete_from_rear() {
        if (is_empt()) {
            printf("Deque is empty. Cannot delete from the rear.\n");
        } else {
            printf("Deleted from the rear: %d\n", deque[rear]);
            if (front == rear) {
                front = rear = -1;
            } else if (rear == 0) {
                rear = MAX_SIZE - 1;
            } else {
                rear--;
            }
        }
    }
    
    // Function to peek at the front element
    int display_front() {
        if (is_empt()) {
            printf("Deque is empty. Cannot peek at the front.\n");
            return -1;
        }
        return deque[front];
    }
    
    // Function to peek at the rear element
    int display_rear() {
        if (is_empt()) {
            printf("Deque is empty. Cannot peek at the rear.\n");
            return -1;
        }
        return deque[rear];
    }
    
    // Function to display the menu and get the user's choice
    int getMenuChoice() {
        int choice;
        printf("\nMenu:\n");
        printf("1. Insert at Front\n");
        printf("2. Insert at Rear\n");
        printf("3. Delete from Front\n");
        printf("4. Delete from Rear\n");
        printf("5. Peek at Front\n");
        printf("6. Peek at Rear\n");
        printf("7. Check if Empty\n");
        printf("8. Check if Full\n");
        printf("9. Print Deque\n");
        printf("10. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        return choice;
    }
    
    // Function to print the entire Deque
    void print_dq() {
        if (is_empt()) {
            printf("Deque is empty.\n");
        } else {
            int i = front;
            printf("Deque: [ ");
            while (1) {
                printf("%d", deque[i]);
                if (i == rear) {
                    break;
                }
                i = (i + 1) % MAX_SIZE;// do not just do i+1
                //it willnot be able ot handle circular nature of dq
                //so while incrementing do 1+1 % 10 = 2%10=2--->remainder
                printf(", ");
            }
            printf(" ]\n");
        }
    }
    
    int main() {
        int choice, value;
    
        while (1) 
            choice = getMenuChoice();
    
            switch (choice)
                case 1:
                    printf("Enter an integer to insert at the front of the Deque: ");
                    scanf("%d", &value);
                    insert_at_front(value);
                    
                     case 2:
                     printf("Enter an integer to insert at the rear of the Deque: ");
                     scanf("%d", &value);
                     insert_at_rear(value);
                     break;
                              
                     case 3:

                    delete_from_front();
                    break;

                    case 4:
                    delete_from_rear();
                    break;

                    case 5:
                    printf("Front element: %d\n", display_front());
                    break;

                            
                    case 6:
                    printf("Rear element: %d\n", display_rear());
                    break;

                    case 7:
                    if (is_empt()) {
                    printf("Deque is empty.\n");
                    } else {
                    printf("Deque is not empty.\n");
                    }
                    break;

                    case 8:
                    if (is_full()) {
                    printf("Deque is full.\n");
                    } else {
                    printf("Deque is not full.\n");
                    }
                    break;

                    case 9:
                    print_dq();
                    break;

                    case 10:
                    return 0;
                    default:
                    printf("Invalid choice. Please try again.\n");
                          
                    return 0;
                  }  
                  

            </pre>
            </div>
            <div class="output">
              <h1>OUTPUT</h1>
              <pre>
                Menu:
                1. Insert at Front
                2. Insert at Rear
                3. Delete from Front
                4. Delete from Rear
                5. Peek at Front
                6. Peek at Rear
                7. Check if Empty
                8. Check if Full
                9. Print Deque
                10. Exit
                Enter your choice: 1
                Enter an integer to insert at the front of the Deque: 14
                Inserted at the front: 14
                
                Menu:
                1. Insert at Front
                2. Insert at Rear
                3. Delete from Front
                4. Delete from Rear
                5. Peek at Front
                6. Peek at Rear
                7. Check if Empty
                8. Check if Full
                9. Print Deque
                10. Exit
                Enter your choice: 2
                Enter an integer to insert at the rear of the Deque: 15
                Inserted at the rear: 15
                
                Menu:
                1. Insert at Front
                2. Insert at Rear
                3. Delete from Front
                4. Delete from Rear
                5. Peek at Front
                6. Peek at Rear
                7. Check if Empty
                8. Check if Full
                9. Print Deque
                10. Exit
                Enter your choice: 4
                Deleted from the rear: 15
                
                Menu:
                1. Insert at Front
                2. Insert at Rear
                3. Delete from Front
                4. Delete from Rear
                5. Peek at Front
                6. Peek at Rear
                7. Check if Empty8. Check if Full
                9. Print Deque
                10. Exit
                Enter your choice: 10
                
              </pre>
            </div>
          </div>
          <div class="question">
            <div class="solve">
              <h2>Ques 10. IMPLEMENT THE OPERATIONS OF DOUBLE ENDED QUEUE IN AN STRING ARRAY (INSERT, DELETE, PEEK,
                ISEMPTY, ISFULL)
              </h2>
              <pre>

                 #include < stdio.h>
                  #include < stdlib.h>
                  #include < string.h>
                  
                  #define MAX_SIZE 10
                  
                  char deque[MAX_SIZE][50];  // Assuming a maximum string length of 49 characters
                  int front = -1, rear = -1;
                  
                  // Function to check if the Deque is empty
                  int is_empty() {
                      return front == -1;
                  }
                  
                  // Function to check if the Deque is full
                  int is_full() {
                      return ((front == 0 && rear == MAX_SIZE - 1) || (rear == front - 1));
                  }
                  
                  // Function to insert a string at the front of the Deque
                  void insert_at_front(char value[50]) {
                      if (is_full()) {
                          printf("Deque is full. Cannot insert at the front.\n");
                      } else {
                          if (front == -1) {
                              front = rear = 0;
                          } else if (front == 0) {
                              front = MAX_SIZE - 1;
                          } else {
                              front--;
                          }
                          strcpy(deque[front], value);
                          printf("Inserted at the front: %s\n", value);
                      }
                  }
                  
                  // Function to insert a string at the rear of the Deque
                  void insert_at_rear(char value[50]) {
                      if (is_full()) {
                          printf("Deque is full. Cannot insert at the rear.\n");
                      } else {
                          if (front == -1) {
                              front = rear = 0;
                          } else if (rear == MAX_SIZE - 1) {
                              rear = 0;
                          } else {
                              rear++;
                          }
                          strcpy(deque[rear], value);
                          printf("Inserted at the rear: %s\n", value);
                      }
                  }
                  
                  // Function to delete a string from the front of the Deque
                  void delete_from_front() {
                      if (is_empty()) {
                          printf("Deque is empty. Cannot delete from the front.\n");
                      } else {
                          printf("Deleted from the front: %s\n", deque[front]);
                          if (front == rear) {
                              front = rear = -1;
                          } else if (front == MAX_SIZE - 1) {
                              front = 0;
                          } else {
                              front++;
                          }
                      }
                  }
                  
                  // Function to delete a string from the rear of the Deque
                  void delete_from_rear() {
                      if (is_empty()) {
                          printf("Deque is empty. Cannot delete from the rear.\n");
                      } else {
                          printf("Deleted from the rear: %s\n", deque[rear]);
                          if (front == rear) {
                              front = rear = -1;
                          } else if (rear == 0) {
                              rear = MAX_SIZE - 1;
                          } else {
                              rear--;
                          }
                      }
                  }
                  
                  // Function to peek at the front string
                  char* display_front() {
                      static char emptyString[50] = "";
                      if (is_empty()) {
                          printf("Deque is empty. Cannot peek at the front.\n");
                          return emptyString;
                      }
                      return deque[front];
                  }
                  
                  // Function to peek at the rear string
                  char* display_rear() {
                      static char emptyString[50] = "";
                      if (is_empty()) {
                          printf("Deque is empty. Cannot peek at the rear.\n");
                          return emptyString;
                      }
                      return deque[rear];
                  }
                  
                  // Function to display the menu and get the user's choice
                  int getMenuChoice() {
                      int choice;
                      printf("\nMenu:\n");
                      printf("1. Insert at Front\n");
                      printf("2. Insert at Rear\n");
                      printf("3. Delete from Front\n");
                      printf("4. Delete from Rear\n");
                      printf("5. Peek at Front\n");
                      printf("6. Peek at Rear\n");
                      printf("7. Check if Empty\n");
                      printf("8. Check if Full\n");
                      printf("9. Print Deque\n");
                      printf("10. Exit\n");
                      printf("Enter your choice: ");
                      scanf("%d", &choice);
                      return choice;
                  }
                  
                  // Function to print the entire Deque
                  void printDeque() {
                      if (is_empty()) {
                          printf("Deque is empty.\n");
                      } else {
                          int i = front;
                          printf("Deque: [ ");
                          while (1) {
                              printf("%s", deque[i]);
                              if (i == rear) {
                                  break;
                              }
                              i = (i + 1) % MAX_SIZE;
                              printf(", ");
                          }
                          printf(" ]\n");
                      }
                  }
                  
                  int main() {
                      int choice;
                      char value[50];
                  
                      while (1) {
                          choice = getMenuChoice();
                  
                          switch (choice) {
                              case 1:
                                  printf("Enter a string to insert at the front of the Deque: ");
                                  scanf(" %49s", value); // Limit the input to 49 characters
                                  insert_at_front(value);
                                  break;
                              case 2:
                                  printf("Enter a string to insert at the rear of the Deque: ");
                                  scanf(" %49s", value); // Limit the input to 49 characters
                                  insert_at_rear(value);
                                  break;
                              case 3:
                                  delete_from_front();
                                  break;
                              case 4:
                              delete_from_rear();
                                  break;
                              case 5:
                                  printf("Front element: %s\n", display_front());
                                  break;
                              case 6:
                                  printf("Rear element: %s\n", display_rear());
                                  break;
                              case 7:
                                  if (is_empty()) {
                                      printf("Deque is empty.\n");
                                  } else {
                                      printf("Deque is not empty.\n");
                                  }
                                  break;
                              case 8:
                                  if (is_full()) {
                                      printf("Deque is full.\n");
                                  } else {
                                      printf("Deque is not full.\n");
                                  }
                                  break;
                              case 9:
                                  printDeque();
                                  break;
                              case 10:
                                  return 0;
                              default:
                                  printf("Invalid choice. Please try again.\n");
                          }
                      }
                  
                      return 0;
                  }

            </pre>
            </div>
            <div class="output">
              <h1>OUTPUT</h1>
              <pre>

              </pre>
            </div>
          </div>
          <div class="question">
            <div class="solve">
              <h2>Ques 11. IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE DYNAMICALLY OF INTEGERS (INSERT, DELETE, PEEK,
                ISEMPTY, ISFULL)
              </h2>
              <pre>
                #include < stdio.h>
                #include < stdlib.h>
                      
                      struct Node{
                          int data;
                          int priority;
                          struct Node *next;
                      };
                      
                      struct Node *head = NULL;
                      struct Node *tail = NULL;
                      
                      int size = 0;
                      
                      void insertFirst(int val,int pri){
                          if(head == NULL){
                              head = (struct Node*)malloc(sizeof(struct Node));
                              head->data = val;
                              head->priority = pri;
                              tail = head;
                              tail->next = NULL;
                              size++;
                              return;
                          }
                          struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                          newNode->data = val;
                          newNode->priority = pri;
                          newNode->next = head;
                          head = newNode;
                          size++;
                      }
                      
                      void insertLast(int val,int pri){
                          if(head == NULL){
                             insertFirst(val,pri);
                              return;
                          }

                          struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                          newNode->data = val;
                          newNode->priority = pri;
                          newNode->next = NULL;
                          tail->next = newNode;
                          tail = newNode;
                          size++;
                      }
                      
                      void insertInMiddle(int val,int pri,int pos){
                          if(pos == 0) {
                              printf("Invalid pos");
                              return;
                          }
                          if(pos == 1){
                              insertFirst(val,pri);
                              return;
                          }
                           if(pos == size){
                             insertLast(val,pri);
                             return;
                          }
                      
                          if(pos > size+1){
                              printf("Invalid pos");
                              return;
                          }

                          struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                          if(newNode !=  NULL){
                            struct Node *prev = head;
                              for(int i = 1; i < pos-1;i++){
                                prev = prev->next;
                          }

                          newNode->data = val;
                          newNode->data = pri;
                          newNode->next = prev->next;
                          prev->next = newNode;
                          size++;
                          }else {
                              printf("LinkedList is Full!");
                          }
                         
                      }
                      
                      int deleteFirst(){
                          if(size == 0){
                              printf("List is Empty!");
                              return -1;
                          }
                          int data = head->data;
                          if(size == 1){
                              head = tail = NULL;
                              size--;
                              return data;
                          }
                          head = head->next;
                          size--;
                          return data;
                      }
                      int deleteLast(){
                           if(size == 0){
                              printf("List is Empty!");
                              return -1;
                          }
                          if(size == 1){
                              return deleteFirst();
                          }
                          struct Node *prev = head;
                          while(prev->next != tail){
                              prev = prev->next;
                          }
                          int data = tail->data;
                          prev->next = NULL;
                          tail = prev;
                          size--;
                          return data;
                      }
                      int deleteInMiddle(int pos){
                          if(pos == 0) {
                              printf("Invalid pos!");
                              return -1;
                          }
                          if(pos == 1) {
                              return deleteFirst();
                          }
                          if(pos == size){
                              return deleteLast();
                          }
                          if(pos > size){
                              printf("Invalid pos!");
                              return -1;
                          }
                          struct Node *temp = head;
                      
                          for(int i = 1; i < pos - 1;i++){
                              temp = temp->next;
                          }
                          if(temp != NULL && temp->next != NULL){
                              int data = temp->next->data;
                              temp->next = temp->next->next;
                              return data;
                          }
                          return -1;
                      }
                      
                      void display(){
                          struct Node *temp = head;
                          while(temp != NULL){
                              printf("%d->",temp->data);
                              temp = temp->next;
                          }
                          printf("null");
                      }
                      
                      
                      void add(int val,int pri){
                          if(size == 0){
                              insertFirst(val,pri);
                              return;
                          }
                          int i = 1;
                          struct Node *temp = head;
                          while(temp != NULL){
                              if(temp->priority > pri){
                                  insertInMiddle(val,pri,i);
                                  break;
                                }
                                i++;
                                temp = temp->next;
                          }
                          if(temp == NULL){
                              insertLast(val,pri);
                          }
                      }
                      
                      int delete(){
                        return deleteFirst();
                      }
                      void main(){
                          add(10,1);
                          add(50,10);
                          add(50,0);
                          add(60,3);
                          add(80,2);
                          add(90,7);
                          display();
                      }

            </pre>
            </div>
            <div class="output">
              <h1>OUTPUT</h1>
              <pre>
                50->10->2->7->50->60->null
              </pre>
            </div>
          </div>
          <div class="question">
            <div class="solve">
              <h2>Ques 12. IMPLEMENT THE OPERATIONS OF PRIORITY QUEUE DYNAMICALLY OF STRING (INSERT, DELETE, PEEK,
                ISEMPTY, ISFULL)
              </h2>
              <pre>
                  #include < stdio.h>
                  #include < stdlib.h>
                  #include < string.h>
                  
                  struct Node{
                      char data[100];
                      int priority;
                      struct Node *next;
                  };
                  
                  struct Node *head = NULL;
                  struct Node *tail = NULL;
                  
                  int size = 0;
                  
                  void insertFirst(char val[],int pri){
                      if(head == NULL){
                          head = (struct Node*)malloc(sizeof(struct Node));
                          strcpy(head->data,val);
                          head->priority = pri;
                          tail = head;
                          tail->next = NULL;
                          size++;
                          return;
                      }
                      struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                      strcpy(newNode->data,val);
                      newNode->priority = pri;
                      newNode->next = head;
                      head = newNode;
                      size++;
                  }
                  
                  void insertLast(char val[],int pri){
                      if(head == NULL){
                         insertFirst(val,pri);
                          return;
                      }
                      struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                      strcpy(newNode->data,val);
                      newNode->priority = pri;
                      newNode->next = NULL;
                      tail->next = newNode;
                      tail = newNode;
                      size++;
                  }
                  
                  void insertInMiddle(char val[],int pri,int pos){
                      if(pos == 0) {
                          printf("Invalid pos");
                          return;
                      }
                      if(pos == 1){
                          insertFirst(val,pri);
                          return;
                      }
                       if(pos == size){
                         insertLast(val,pri);
                         return;
                      }
                  
                      if(pos > size+1){
                          printf("Invalid pos");
                          return;
                      }
                      struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                      if(newNode !=  NULL){
                        struct Node *prev = head;
                          for(int i = 1; i < pos-1;i++){
                          prev = prev->next;
                      }
                      strcpy(newNode->data,val);
                      newNode->priority = pri;
                      newNode->next = prev->next;
                      prev->next = newNode;
                      size++;
                      }else {
                          printf("LinkedList is Full!");
                      }
                     
                  }
                  
                  char* deleteFirst(){
                      if(size == 0){
                          printf("List is Empty!");
                          return NULL;
                      }
                      char *data = head->data;
                      if(size == 1){
                          head = tail = NULL;
                          size--;
                          return data;
                      }
                      head = head->next;
                      size--;
                      return data;
                  }
                  
                  
                  void display(){
                      struct Node *temp = head;
                      while(temp != NULL){
                          printf("%s->",temp->data);
                          temp = temp->next;
                      }
                      printf("null");
                  }
                  
                  
                  void add(char val[],int pri){
                      if(size == 0){
                          insertFirst(val,pri);
                          return;
                      }
                      int i = 1;
                      struct Node *temp = head;
                      while(temp != NULL){
                          if(temp->priority > pri){
                              insertInMiddle(val,pri,i);
                              break;
                            }
                            i++;
                            temp = temp->next;
                      }
                      if(temp == NULL){
                          insertLast(val,pri);
                      }
                  }
                  
                  char* delete(){
                    return deleteFirst();
                  }
                  char *peek(){
                      return head->data;
                  }
                  void main(){
                      add("by",5);
                      add("faham",2);
                      add("hello!",1);
                      add("oyee",0);
                      display();
                      printf("\nThe remove value is : %s\n",delete());
                      display();
                  }

            </pre>
            </div>
            <div class="output">
              <h1>OUTPUT</h1>
              <pre>
                oyee->hello!->faham->by->null
                The remove value is : oyee
                hello!->faham->by->null
              </pre>
            </div>
          </div>
          <div class="question">
            <div class="solve">
              <h2>Ques 13. Find the first circular tour that visits all petrol pumps
              </h2>
              <pre>


            </pre>
            </div>
            <div class="output">
              <h1>OUTPUT</h1>
              <pre>

              </pre>
            </div>
          </div>
          <div class="question">
            <div class="solve">
              <h2>Ques 14. Length of the longest valid substring.
              </h2>
              <pre>
                #include <stdio.h>
                  #include <string.h>
                  #include <stdlib.h>
                 #define MAX 4
                  
                  int stack[MAX];
                  int top = -1;
                  
                  int isEmpty(){
                      if(top == -1) return 1;
                      return 0;
                  }
                  
                  int isFull(){
                      if(top == MAX-1) return 1;
                      return 0;
                  }
                  
                  void push(int val){
                      if(isFull()){
                          printf("Stack is full!");
                          return;
                      }
                      stack[++top] = val;
                  }
                  
                  int pop(){
                      if(isEmpty()){
                          printf("Stack is Empty!");
                          return __INT_MAX__;
                      }
                      int data = stack[top--];
                      return data;
                  }
                  int peek(){
                       if(isEmpty()){
                          printf("Stack is Empty!");
                          return __INT_MAX__;
                      }
                      return stack[top];
                  }
                  
                  int getmax(int a,int b){
                      if(a>b)return a;
                      return b;
                  }
                  int longestValidString(char str[]){
                    int count = 0;
                    int max = 0;
                    for(int i = 0;i < strlen(str);i++){
                        char ch = str[i];
                        if(ch == '('){
                            push(ch);
                        }else {
                            if((isEmpty() == 0) && (peek() == '(')){
                                pop();
                                count += 2;
                            }else {
                                max = getmax(max,count);
                                count = 0;
                            }
                        }
                    }
                    max = getmax(max,count);
                    return max;
                }  
                void main(){
                    char str[] = "(())))))";
                    int ans = longestValidString(str);
                    printf("The logest valid substring is : %d ",ans);
                }
                

            </pre>
            </div>
            <div class="output">
              <h1>OUTPUT</h1>
              <pre>
                The logest valid substring is :4
              </pre>
            </div>
          </div>

          <div class="question">
            <div class="solve">
              <h2>Ques 15. Find the Next Greater Element.
              </h2>
              <pre>
                #include < stdio.h>
               

                  //Next greater element
                      void nextGreater(int arr[],int ans[],int n){
                          int i,j = n-1;
                          for(i = n-1; i >=0;i--){
                              while(isEmptySt() == 0 && peek() <= arr[i]){
                                  pop();
                              }
                              if(isEmptySt()) ans[j--] = -1;
                              else {
                                  ans[j--] = peek();
                              };
                              push(arr[i]);
                          }
                      }
                      
                      //Queue reversal
                      void main(){
                         int arr[] = {6,8,1,0,1,3};
                         int ans[6];
                         nextGreater(arr,ans,6);
                         for(int i = 0; i< 6;i++){
                          printf("%d ",ans[i]);
                         }
                      }

            </pre>
            </div>
            <div class="output">
              <h1>OUTPUT</h1>
              <pre>
                8 -1 3 1 3 -1 

              </pre>
            </div>
          </div>
          <div class="question">
            <div class="solve">
              <h2>Ques 16. Find Next Smaller Element.
              </h2>
              <pre>
                #include < stdio.h>
                
                  //Next Smaller element

                      void nextSmaller(int arr[],int ans[],int n){
                          int i,j = n-1;
                          for(i = n-1; i >=0;i--){
                              while(isEmptySt() == 0 && peek() >= arr[i]){
                                  pop();
                              }
                              if(isEmptySt()) ans[j--] = -1;
                              else {
                                  ans[j--] = peek();
                              };
                              push(arr[i]);
                          }
                      }
                      
                      void main(){
                         int arr[] = {6,8,1,0,1,3};
                         int ans[6];
                         nextSmaller(arr,ans,6);
                         for(int i = 0; i< 6;i++){
                          printf("%d ",ans[i]);
                         }
                      }

            </pre>
            </div>
            <div class="output">
              <h1>OUTPUT</h1>
              <pre>
                1 1 0 -1 -1 -1  
              </pre>
            </div>
          </div>
          <div class="question">
            <div class="solve">
              <h2>Ques 17. Queue based approach for first non-repeating character in a stream.
              </h2>
              <pre>

                      #include < stdio.h>
                      #include < string.h>
                      #include < stdlib.h>
                      #define MAX 20
                      int front = -1;
                      int rear = -1;
                      int size = 0;
                      char queue[MAX];
                      
                      void enqueue(char val){
                          if(size == MAX){
                              printf("Queue is Full!");
                              return;
                          }
                          size++;
                          if(front == -1 && rear == -1){
                              //enqueueing first time
                              front = rear = 0;
                              queue[rear] = val;
                              return;
                          }
                          rear++;
                          queue[rear] = val;
                      }
                      
                      char dequeue(){
                          if(size == 0) {
                              printf("Queue is Empty!");
                              return ' ';
                          }
                          if(size == 1){
                              char val = queue[front];
                              front = rear = -1;
                              size = 0;
                              return val;
                          }
                          //shifting items towards left.
                          char val = queue[front];
                          for(int i = front+1; i <= rear;i++){
                              queue[i-1] = queue[i];
                          }
                          rear--;
                          size--;
                          return val;
                      }
                      
                      void display(){
                          if(size == 0) {
                           printf("Queue is Empty!");
                           return ;
                          }
                          for(int i = front; i <= rear;i++){
                              printf("%c ",queue[i]);
                          }
                      }
                      
                      char peek(){
                           if(size == 0) {
                              printf("Queue is Empty!");
                              return ' ';
                          }
                          return queue[front];
                      }
                      int isEmpty(){
                          if(size == 0){
                              return 1;
                          }
                          return 0;
                      }
                      
                      void firstNonRepeating(char str[],int n){
                          int freq[26];
                          for(int i = 0;i < 26;i++){
                              freq[i] = 0;
                          }
                          for(int i = 0;i < n-1;i++){
                            freq[str[i] - 'a']++;
                            enqueue(str[i]);
                            while(isEmpty() == 0 && freq[peek() - 'a'] > 1){
                              dequeue();
                            }
                            if(isEmpty()) printf("-1 ");
                            else printf("%c ",peek());
                          }
                      }
                      
                      void main(){
                          char str[] = "aabbxxc";
                          firstNonRepeating(str,strlen(str));
                      
                      }

            </pre>
            </div>
            <div class="output">
              <h1>OUTPUT</h1>
              <pre>
                a -1 b -1 x -1 
              </pre>
            </div>
          </div>
          <div class="question">
            <div class="solve">
              <h2>Ques 18. Reverse First K elements of Queue.
              </h2>
              <pre>
                #include < stdio.h>
                #include < string.h>
                #include < stdlib.h>
                #define MAX 20

                int front = -1;
                int rear = -1;
                int size = 0;
                char queue[MAX];
                
                void enqueue(char val){
                    if(size == MAX){
                        printf("Queue is Full!");
                        return;
                    }
                    size++;
                    if(front == -1 && rear == -1){
                        //enqueueing first time
                        front = rear = 0;
                        queue[rear] = val;
                        return;
                    }
                    rear++;
                    queue[rear] = val;
                }
                
                char dequeue(){
                    if(size == 0) {
                        printf("Queue is Empty!");
                        return ' ';
                    }
                    if(size == 1){
                        char val = queue[front];
                        front = rear = -1;
                        size = 0;
                        return val;
                    }
                    //shifting items towards left.
                    char val = queue[front];
                    for(int i = front+1; i <= rear;i++){
                        queue[i-1] = queue[i];
                    }
                    rear--;
                    size--;
                    return val;
                }
                
                void display(){
                    if(size == 0) {
                     printf("Queue is Empty!");
                     return ;
                    }
                    for(int i = front; i <= rear;i++){
                        printf("%c ",queue[i]);
                    }
                }
                
                char peek(){
                     if(size == 0) {
                        printf("Queue is Empty!");
                        return ' ';
                    }
                    return queue[front];
                }
                int isEmpty(){
                    if(size == 0){
                        return 1;
                    }
                    return 0;
                }
                
                // Reverse first K elements of a queue
                void reverseQueue(int size){
                    int i = 0;
                    int arr[size];
                    while(i < size){
                        arr[i] = deque();
                        i++;
                    }
                    for(int j = size-1;j >=0;j--){
                        enque(arr[j]);
                    }
                }
                
                void main(){
                   enque(1);
                   enque(2);
                   enque(3);
                   enque(4);
                   enque(5);
                
                   display();
                   reverseQueue(3);
                   printf("\n");
                   display();
                }
              

            </pre>
            </div>
            <div class="output">
              <h1>OUTPUT</h1>
              <pre>
                1 2 3 4 5 
                5 4 3 2 1 
              </pre>
            </div>
          </div>
          <div class="question">
            <div class="solve">
              <h2>Ques 19. Queue Reversal.
              </h2>
              <pre>
                      #include < stdio.h>
                      #include < string.h>
                      #include < stdlib.h>
                      #define MAX 20
                      int front = -1;
                      int rear = -1;
                      int size = 0;
                      char queue[MAX];
                      
                      void enqueue(char val){
                          if(size == MAX){
                              printf("Queue is Full!");
                              return;
                          }
                          size++;
                          if(front == -1 && rear == -1){
                              //enqueueing first time
                              front = rear = 0;
                              queue[rear] = val;
                              return;
                          }
                          rear++;
                          queue[rear] = val;
                      }
                      
                      char dequeue(){
                          if(size == 0) {
                              printf("Queue is Empty!");
                              return ' ';
                          }
                          if(size == 1){
                              char val = queue[front];
                              front = rear = -1;
                              size = 0;
                              return val;
                          }
                          //shifting items towards left.
                          char val = queue[front];
                          for(int i = front+1; i <= rear;i++){
                              queue[i-1] = queue[i];
                          }
                          rear--;
                          size--;
                          return val;
                      }
                      
                      void display(){
                          if(size == 0) {
                           printf("Queue is Empty!");
                           return ;
                          }
                          for(int i = front; i <= rear;i++){
                              printf("%c ",queue[i]);
                          }
                      }
                      
                      char peek(){
                           if(size == 0) {
                              printf("Queue is Empty!");
                              return ' ';
                          }
                          return queue[front];
                      }
                      int isEmpty(){
                          if(size == 0){
                              return 1;
                          }
                          return 0;
                      }
                      
                      // Reverse first K elements of a queue
                      void reverseQueue(int size){
                          int i = 0;
                          int arr[size];
                          while(i < size){
                              arr[i] = deque();
                              i++;
                          }
                          for(int j = size-1;j >=0;j--){
                              enque(arr[j]);
                          }
                      }
                      
                      void main(){
                         enque(1);
                         enque(2);
                         enque(3);
                         enque(4);
                         enque(5);
                      
                         display();
                         reverseQueue(size);
                         printf("\n");
                         display();
                      }        
                    

            </pre>
            </div>
            <div class="output">
              <h1>OUTPUT</h1>
              <pre>
                1 2 3 4 5 
                5 4 3 2 1 
          
              </pre>
            </div>
          </div>
          <!----------------------------LL---------------------------------------------------->
          <section id="LinkedList">
            <h1>LinkedList</h1>
            <div class="question">
              <div class="solve">
                <h2>Ques 1. IMPLEMENT THE OPERATIONS OF SINGLE LINKED LIST STORING INTEGER VALUES
                  (INSERT AT BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY,
                  ISFULL, DISPLAY, SEARCH) </h2>
                <pre>
                  #include <stdio.h>
                    #include <stdlib.h>
                    struct LL {
                        int data;
                        struct LL *next;
                    };
                    struct LL *head = NULL;
                    struct LL *tail = NULL;
                    struct LL *newnode;
                    int size = 0;
                    
                    void insertFirst(int val){
                        //first time insert or use head == NULL
                        if(size == 0){
                            head = (struct LL*)malloc(sizeof(struct LL));
                            head->data = val;
                            tail = head;
                            head->next = NULL;
                            size++;
                            return;
                        }
                        if(size == 1){
                        newnode = (struct LL*)malloc(sizeof(struct LL));
                        if(newnode != NULL){
                            newnode->data = val;
                            newnode->next = head;
                            head = newnode;
                            return;
                        }
                        else printf ("LL is Full\n");
                    }
                    }
                    //insert at last
                    void insertAtLast(int val){
                        if(size == 0){
                            insertFirst(val);
                            return;
                        }
                    newnode =  (struct LL*)malloc(sizeof(struct LL));
                    newnode->data = val;
                    newnode->next = NULL;
                    tail->next = newnode;
                    tail = newnode;
                    size++;
                    return;
                    }
                    //inser in between 
                    void insertAtPos(int val,int pos){
                         if(pos == 0 || pos > size ){
                        //we are strting from 1 so 0 is invalid
                        //and if user press 7 but ll is only 5 nodes its impossible to join
                            printf("Invalis position\n");
                            return;
                        }
                        if(pos == 1){
                            insertFirst(val);
                            return;
                        }
                        if(pos == size){
                           insertAtLast(val);
                           return;
                        }
                    newnode =  (struct LL*)malloc(sizeof(struct LL));
                    if(newnode != NULL){
                        struct LL *prev = head;
                        for(int i = 1;i<pos-1;i++){
                            prev = prev->next;
                        }
                        newnode->data = val;
                        newnode->next = prev->next;
                        prev->next = newnode;
                        size++;
                        return;
                    }else printf ("LL is Full\n"); 
                    }
                    void deleteFirst(){
                        if(size == 0){
                            printf("LL is empty\n");
                            return;
                        }
                        if(size == 1){
                            head = tail = NULL;
                            size --;
                            return;
                        }
                        head = head->next;
                        size--;
                        return;
                    }
                    void deleteLast(){
                        if(size == 0){
                       printf("LL is empty\n");
                            return;
                    }
                    if(size == 1){
                        deleteFirst();
                        return;
                    }
                    struct LL *prev = head;
                    while(prev->next != tail){
                        prev = prev->next;
                    }
                    prev->next = NULL;
                    tail = prev;
                    }
                    //delete between nodes
                    void deleteAtPos(int pos){
                        if(pos > size){
                            printf("Invalid\n");
                        }
                       if(pos == 0){
                       printf("LL is empty\n");
                            return;
                    }
                    if(pos == 1){
                        deleteFirst();
                        return;
                    }
                    struct LL *prev = head;
                    for(int i = 1;i < pos-1; i++){
                        prev  = prev->next;
                    }
                    if(prev != NULL && prev->next != NULL){
                        prev->next = prev->next->next;
                    }
                    }
                    int search(int key){
                        if(size == 0){
                            printf("LL is Empty\n");
                            return -1;
                        }
                        int indx = 0;
                        struct LL *temp = head;
                        while(temp != NULL){
                        if(temp->data == key){
                            return indx;
                        }
                        temp = temp->next;
                        indx++;
                    }
                    return -1;
                    }
                    void display(){
                        struct LL *temp = head;
                        while (temp != NULL){
                            printf("%d->",temp->data);
                            temp = temp->next;
                        }
                        printf("NULL\n");
                    }
                    int main() {
                          insertFirst(4);
                          insertFirst(3);
                          insertFirst(2);
                          insertFirst(1);
                          insertAtLast(5);
                          insertAtLast(6);
                          insertAtLast(7);
                          /*
                          insertAtPos(20,3);
                          display();
                          deleteFirst();
                          deleteLast();
                          deleteAtPos(2);
                          display();
                          */
                          int key;
                          printf("search for key\n");
                          scanf("%d",&key);
                          int res = search(key);
                          if(res != -1){
                              printf("key is found at index : %d\n",res);
                          }else printf("not found\n");
                          display();
                        return 0;
                    }
                  
              </pre>
              </div>
              <div class="output">
                <h1>OUTPUT</h1>
                <pre>
                  search for key
                  3
                  key is found at index : 2
                  1->2->3->4->5->6->7->NULL
                </pre>
              </div>
            </div>
            <div class="question">
              <div class="solve">
                <h2>Ques 2. IMPLEMENT THE OPERATIONS OF SINGLE CIRCULAR LINKED LIST STORING INTEGER VALUES (INSERT AT
                  BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL,
                  DISPLAY, SEARCH)</h2>
                <pre>

                  #include <stdio.h>
                    #include <stdlib.h>
                        
                        struct Node{
                            int data;
                            struct Node *next;
                        };
                        
                        struct Node *head = NULL;
                        struct Node *tail = NULL;
                        
                        int size = 0;
                        
                        void insertFirst(int val){
                            if(head == NULL){
                                head = (struct Node*)malloc(sizeof(struct Node));
                                head->data = val;
                                tail = head;
                                tail->next = NULL;
                                size++;
                                return;
                            }
                            struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                            newNode->data = val;
                            newNode->next = head;
                            head = newNode;
                            size++;
                        }
                        
                        void insertLast(int val){
                            if(head == NULL){
                               insertFirst(val);
                                return;
                            }
                            struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                            newNode->data = val;
                            newNode->next = head;
                            tail->next = newNode;
                            tail = newNode;
                            size++;
                        }
                        
                        void insertInMiddle(int val,int pos){
                            if(pos == 0) {
                                printf("Invalid pos");
                                return;
                            }
                            if(pos == 1){
                                insertFirst(val);
                                return;
                            }
                             if(pos == size){
                               insertLast(val);
                               return;
                            }
                        
                            if(pos > size+1){
                                printf("Invalid pos");
                                return;
                            }
                            struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                            if(newNode !=  NULL){
                              struct Node *prev = head;
                                for(int i = 1; i < pos-1;i++){
                                prev = prev->next;
                            }
                            newNode->data = val;
                            newNode->next = prev->next;
                            prev->next = newNode;
                            size++;
                            }else {
                                printf("LinkedList is Full!");
                            }
                           
                        }
                        
                        int deleteFirst(){
                            if(size == 0){
                                printf("List is Empty!");
                                return -1;
                            }
                            int data = head->data;
                            if(size == 1){
                                head = tail = NULL;
                                size--;
                                return data;
                            }
                            head = head->next;
                            size--;
                            return data;
                        }
                        int deleteLast(){
                             if(size == 0){
                                printf("List is Empty!");
                                return -1;
                            }
                            if(size == 1){
                                return deleteFirst();
                            }
                            struct Node *prev = head;
                            while(prev->next != tail){
                                prev = prev->next;
                            }
                            int data = tail->data;
                            prev->next = head;
                            tail = prev;
                            size--;
                            return data;
                        }
                        
                        int search(int key){
                            if(size == 0){
                                printf("List is Empty!");
                                return -1; 
                            }
                            int indx = 0;
                            struct Node *temp = head;
                            while(temp != NULL){
                                if(temp->data == key){
                                    return indx;
                                }
                                temp = temp->next;
                                indx++;
                            }
                            return -1;
                        }
                        
                        
                        void sortList(){
                            if(size == 0 || size == 1) return;
                            for(int i = 0; i < size-1;i++){
                                struct Node *cur = head;
                                for(int j = 0;j < size - 1 - i;j++){
                                    if(cur->next != head){
                                        if(cur->data > cur->next->data){
                                            int t = cur->data;
                                            cur->data = cur->next->data;
                                            cur->next->data = t;
                                        }
                                    }
                                    cur = cur->next;
                                }
                            }
                        }
                        
                        
                        int deleteInMiddle(int pos){
                            if(pos == 0) {
                                printf("Invalid pos!");
                                return -1;
                            }
                            if(pos == 1) {
                                return deleteFirst();
                            }
                            if(pos == size){
                                return deleteLast();
                            }
                            if(pos > size){
                                printf("Invalid pos!");
                                return -1;
                            }
                            struct Node *temp = head;
                        
                            for(int i = 1; i < pos - 1;i++){
                                temp = temp->next;
                            }
                            if(temp != NULL && temp->next != NULL){
                                int data = temp->data;
                                temp->next = temp->next->next;
                                return data;
                            }
                            return -1;
                        }
                        
                        
                        void display(){
                            struct Node *temp = head;
                            while(temp != NULL && temp->next != head){
                                printf("%d->",temp->data);
                                temp = temp->next;
                            }
                            printf("\n");
                        }
                        
                        void main(){
                            insertFirst(10);
                            insertFirst(20);
                            insertFirst(30);
                            insertFirst(40);
                            insertInMiddle(25,3);
                            display();
                            sortList();
                            int ans =  search(20);
                           if(ans != -1){
                               printf("key is fount at index : %d\n",ans);
                           }else printf("key is not found \n");
                            display();
                        }
                 
              </pre>
              </div>
              <div class="output">
                <h1>OUTPUT</h1>
                <pre>
                  40->30->25->20->10->
                  key is fount at index : 1
                  10->20->25->30->40->
                </pre>
              </div>
            </div>
            <div class="question">
              <div class="solve">
                <h2>Ques 3. IMPLEMENT THE OPERATIONS OF DOUBLY LINKED LIST STORING INTEGER VALUES (INSERT AT
                  BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL,
                  DISPLAY, SEARCH)</h2>
                <pre>
                  #include < stdio.h>
                    #include < stdlib.h>
                    struct LL {
                        int data;
                        struct LL *next;
                        struct LL *prev;
                    };
                    struct LL *tail = NULL;
                    struct LL *head = NULL;
                    struct LL *newnode;
                    int size = 0;
                    
                    
                    void insertFirst(int val){
                        if(head == NULL){
                        head = (struct LL*)malloc(sizeof(struct LL));
                        head->data = val;
                        tail = head;
                        tail->next = NULL;
                        head->prev = NULL;
                        tail->prev = NULL;
                        size++;
                        return;
                        }
                        newnode = (struct LL*)malloc(sizeof(struct LL));
                        newnode->data = val;
                        newnode->next = head;
                        newnode->prev = NULL;
                        head = newnode;
                        size++;
                        return;
                    }
                    void insertLast(int val){
                        if(head == NULL){
                            insertFirst(val);
                            return;
                        }
                        newnode = (struct LL*)malloc(sizeof(struct LL));
                        newnode->data  = val;
                        newnode->next = NULL;
                        newnode->prev = tail;
                        tail->next = newnode;
                        tail = newnode;
                        size++;
                        return;
                    }
                    void insertAtPos(int val,int pos){
                        if(pos == 0 || pos > size+1){
                            printf("invalid\n");
                        }
                        if(pos == 1){
                        insertFirst(val);
                        return;
                        }
                        if(pos == size){
                            insertLast(val);
                        }
                        newnode = (struct LL*)malloc(sizeof(struct LL));
                        if(newnode != NULL){
                        struct LL *prev = head;
                        for(int i = 1;i < pos-1;i++){
                            prev = prev->next;
                        }
                        newnode->data = val;
                        newnode->next = prev->next;
                        prev->next->prev = newnode;
                        prev->next = newnode;
                        newnode->prev = prev;
                        size++;
                        return;
                            
                        }else printf("LL is full\n");
                        
                    }
                     void display(){
                            struct LL *temp = head;
                             printf("null<->");
                            while(temp != NULL){
                                printf("%d<->",temp->data);
                                temp = temp->next;
                            }
                            printf("null\n");
                        }
                    void deleteFirst(){
                        if(size == 0){
                            printf("LL is Empty\n");return;
                        }
                        if(size == 1){
                            tail = head = NULL;
                            size--;
                            return;
                        }
                        head = head->next;
                        head->prev = NULL;
                        size--;
                        return;
                    }
                        void deleteLast(){
                             if(size == 0){
                                printf("List is Empty!");
                                return;
                            }
                            if(size == 1){
                                deleteFirst();
                                return;
                            }
                            struct LL *prev = head;
                            while(prev->next != tail){
                                prev = prev->next;
                            }
                            prev->next = NULL;
                            tail = prev;
                            size--;
                        }
                        void deleteAtPos(int pos){
                            if(pos == 0 || pos > size+1){
                                printf("invalid\n");
                                return;
                            }
                            if(pos == 1){
                                deleteFirst();return;
                            }
                            if(pos == size){
                                deleteLast();return;
                            }
                            //we need pos so traverse
                            struct LL *temp = head;
                            for(int i = 1;i < pos-1;i++){
                                temp = temp->next;
                            }
                            if(temp != NULL && temp->next != NULL){
                              temp->next = temp->next->next;
                              temp->next->next->prev = temp;
                            }
                        }
                            void deleteInMiddle(int pos){
                            if(pos == 0) {
                                printf("Invalid pos!");
                                return;
                            }
                            if(pos == 1) {
                                return deleteFirst();
                            }
                            if(pos == size){
                                deleteLast();
                                return ;
                            }
                            if(pos > size){
                                printf("Invalid pos!");
                                return ;
                            }
                            struct LL *temp = head;
                        
                            for(int i = 1; i < pos - 1;i++){
                                temp = temp->next;
                            }
                            if(temp != NULL && temp->next != NULL){
                                temp->next = temp->next->next;
                                temp->next->next->prev = temp;
                            }
                            }
                       int search(int key){
                          if(size == 0){
                              printf("LL is empty\n");
                              return;
                          }
                          int index = 0;
                          struct LL *temp = head;
                          while(temp != NULL){
                              if(temp->data == key){
                                  return index;
                              }
                              temp = temp->next;
                          }
                          return -1;
                       } 
                       void sortList(){
                           if(size == 0 || size == 1){
                               return;
                           }
                           for(int i = 0;i < size-1;i++){
                               struct LL *curr = head;
                               for(int j = 0;j < size-1;j++){
                                   if(curr->next != NULL){
                                    if(curr->data > curr->next->data){
                                        int temp = curr->data;
                                        curr->data = curr->next->data;
                                        curr->next->data = temp;
                                    }
                               }
                               curr = curr->next;
                           }
                          }
                       }
                    int main() {
                       insertFirst(5);
                       insertFirst(4);
                       insertFirst(8);
                       insertFirst(2);
                       insertFirst(1);
                       insertLast(6);
                       insertAtPos(20,3);
                       sortList();
                       display();
                           //deleteFirst();
                           //deleteLast();
                           //deleteInMiddle(3);
                          // deleteAtPos(5);
                        return 0;
                    }
                    
              </pre>
              </div>
              <div class="output">
                <h1>OUTPUT</h1>
                <pre>
                  null<->1<->2<->4<->5<->6<->8<->20<->null
                </pre>
              </div>
            </div>
            <div class="question">
              <div class="solve">
                <h2>Ques 4. IMPLEMENT THE OPERATIONS OF DOUBLY CIRCULAR LINKED LIST STORING INTEGER VALUES (INSERT AT
                  BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL,
                  DISPLAY, SEARCH)</h2>
                <pre>

                  #include <stdio.h>
                    #include <stdlib.h>
                    
                    struct Node{
                        int data;
                        struct Node *next;
                    };
                    
                    struct Node *head = NULL;
                    struct Node *tail = NULL;
                    
                    int size = 0;
                    
                    void insertFirst(int val){
                        if(head == NULL){
                            head = (struct Node*)malloc(sizeof(struct Node));
                            head->data = val;
                            tail = head;
                            tail->next = NULL;
                            size++;
                            return;
                        }
                        struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                        newNode->data = val;
                        newNode->next = head;
                        head = newNode;
                        size++;
                    }
                    
                    void insertLast(int val){
                        if(head == NULL){
                           insertFirst(val);
                            return;
                        }
                        struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                        newNode->data = val;
                        newNode->next = head;
                        tail->next = newNode;
                        tail = newNode;
                        size++;
                    }
                    
                    void insertInMiddle(int val,int pos){
                        if(pos == 0) {
                            printf("Invalid pos");
                            return;
                        }
                        if(pos == 1){
                            insertFirst(val);
                            return;
                        }
                         if(pos == size){
                           insertLast(val);
                           return;
                        }
                    
                        if(pos > size+1){
                            printf("Invalid pos");
                            return;
                        }
                        struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                        if(newNode !=  NULL){
                          struct Node *prev = head;
                            for(int i = 1; i < pos-1;i++){
                            prev = prev->next;
                        }
                        newNode->data = val;
                        newNode->next = prev->next;
                        prev->next = newNode;
                        size++;
                        }else {
                            printf("LinkedList is Full!");
                        }
                       
                    }
                    
                    int deleteFirst(){
                        if(size == 0){
                            printf("List is Empty!");
                            return -1;
                        }
                        int data = head->data;
                        if(size == 1){
                            head = tail = NULL;
                            size--;
                            return data;
                        }
                        head = head->next;
                        size--;
                        return data;
                    }
                    int deleteLast(){
                         if(size == 0){
                            printf("List is Empty!");
                            return -1;
                        }
                        if(size == 1){
                            return deleteFirst();
                        }
                        struct Node *prev = head;
                        while(prev->next != tail){
                            prev = prev->next;
                        }
                        int data = tail->data;
                        prev->next = head;
                        tail = prev;
                        size--;
                        return data;
                    }
                    
                    int search(int key){
                        if(size == 0){
                            printf("List is Empty!");
                            return -1; 
                        }
                        int indx = 0;
                        struct Node *temp = head;
                        while(temp != NULL){
                            if(temp->data == key){
                                return indx;
                            }
                            temp = temp->next;
                            indx++;
                        }
                        return -1;
                    }
                    
                    
                    void sortList(){
                        if(size == 0 || size == 1) return;
                        for(int i = 0; i < size-1;i++){
                            struct Node *cur = head;
                            for(int j = 0;j < size - 1 - i;j++){
                                if(cur->next != head){
                                    if(cur->data > cur->next->data){
                                        int t = cur->data;
                                        cur->data = cur->next->data;
                                        cur->next->data = t;
                                    }
                                }
                                cur = cur->next;
                            }
                        }
                    }
                    
                    
                    int deleteInMiddle(int pos){
                        if(pos == 0) {
                            printf("Invalid pos!");
                            return -1;
                        }
                        if(pos == 1) {
                            return deleteFirst();
                        }
                        if(pos == size){
                            return deleteLast();
                        }
                        if(pos > size){
                            printf("Invalid pos!");
                            return -1;
                        }
                        struct Node *temp = head;
                    
                        for(int i = 1; i < pos - 1;i++){
                            temp = temp->next;
                        }
                        if(temp != NULL && temp->next != NULL){
                            int data = temp->data;
                            temp->next = temp->next->next;
                            return data;
                        }
                        return -1;
                    }
                    
                    
                    void display(){
                        struct Node *temp = head;
                        while(temp != NULL && temp->next != head){
                            printf("%d->",temp->data);
                            temp = temp->next;
                        }
                        printf("null");
                    }
                    
                    void main(){
                        insertFirst(10);
                        insertFirst(20);
                        insertFirst(30);
                        insertFirst(40);
                        insertInMiddle(25,3);
                        display();
                    }
              </pre>
              </div>
              <div class="output">
                <h1>OUTPUT</h1>
                <pre>
                  40->30->25->20->10->null

                </pre>
              </div>
            </div>
            <div class="question">
              <div class="solve">
                <h2>Ques 5. IMPLEMENT THE OPERATIONS OF SINGLE LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT
                  AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)

                </h2>
                <pre>

                  #include <stdio.h>
                    #include<stdlib.h>
                    #include <string.h>
                    struct LL{
                        char data[100];
                        struct LL *next;
                    };
                    struct LL *head = NULL;
                    struct LL *tail = NULL;
                    struct LL *newnode;
                    int size = 0;
                    
                    
                    void insertFirst(char str[]){
                        if(head == NULL){
                            head = (struct LL*)malloc(sizeof(struct LL));
                            //copy one string into another string
                            strcpy(head->data,str);
                            tail = head;
                            tail->next = NULL;
                            size++;
                            return;
                        }
                        newnode = (struct LL*)malloc(sizeof(struct LL));
                        strcpy(newnode->data,str);
                        newnode->next = head;
                        head = newnode;
                        size++;
                        return;
                    }
                    void insertLast(char str[]){
                        if(size == 0){
                            insertFirst(str);
                            return;
                        }
                        newnode = (struct LL*)malloc(sizeof(struct LL));
                        strcpy(newnode->data,str);
                        newnode->next = NULL;
                        tail->next = newnode;
                        tail = newnode;
                        size++;
                        return;
                    }
                    void insertAtPos(char str[],int pos){
                         if(pos == 0 || pos > size+1) {
                                printf("Invalid pos");
                                return;
                            }
                            if(pos == 1){
                                insertFirst(str);
                                return;
                            }
                             if(pos == size){
                               insertLast(str);
                               return;
                            }
                       newnode = (struct LL*)malloc(sizeof(struct LL));
                       if(newnode != NULL){
                           struct LL *prev = head;
                           for(int i = 1;i<pos-1;i++){
                               prev = prev->next;
                           }
                           strcpy(newnode->data,str);
                           newnode->next = prev->next;
                           prev->next = newnode;
                           size++;
                           return;
                       }else printf("LL is full\n");
                       
                    }
                    void display(){
                        struct LL *temp = head;
                        while(temp != NULL){
                            printf("%s->",temp->data);
                            temp = temp->next;
                        }
                        printf("NULL\n");
                    }
                    void deleteFirst(){
                        if(size == 0){
                            printf("LL is empty\n");
                            return;
                        }
                        if(size == 1){
                        head = tail = NULL;
                        size--;
                        return;
                        }
                        head = head->next;
                        size--;
                        return;
                    }
                    void deleteLast(){
                         if(size == 0){
                            printf("LL is empty\n");
                            return;
                        }
                        if(size == 1){
                        head = tail = NULL;
                        size--;
                        return;
                        }
                        struct LL *prev = head;
                        while(prev->next != tail){
                            prev = prev->next;
                        }
                        prev->next = NULL;
                        tail = prev;
                        size--;
                        return;
                    }
                    void deleteAtPos(int pos){
                            if(pos == 0) {
                                printf("Invalid pos!");
                                return ;
                            }
                            if(pos == 1) {
                                deleteFirst();
                                return ;
                            }
                            if(pos == size){
                                deleteLast();
                                return ;
                            }
                            if(pos > size){
                                printf("Invalid pos!");
                                return ;
                            }
                         struct LL *prev = head;
                         for(int i = 1;i<pos-1;i++){
                            prev = prev->next;
                        }
                        if(prev != NULL && prev->next != NULL){
                        prev->next = prev->next->next;
                        return;    
                    }
                    return;
                    }
                    void sortList(){
                        if(size == 0 || size == 1){
                            return;
                        }
                        for(int i = 0;i<size-1;i++){
                            struct LL *curr = head;
                        for(int j = 0;j<size-1;j++){
                            if(strcmp(curr->data,curr->next->data)>1){
                                char temp[100];
                                strcmp(temp,curr->data);
                                strcmp(curr->data,curr->next->data);
                                strcmp(curr->next->data,temp);
                            }
                            curr = curr->next;
                        }
                      }
                    }
                    int search(char str[]){
                        if(size == 0){
                            printf("LL is empty\n");
                            return 0;
                        }
                        struct LL *temp = head;
                        int index = 0;
                        while(temp != NULL){
                            if(strcmp(temp->data,str)==0){
                                return index;
                            }
                            temp = temp->next;
                            index++;
                        }
                        return -1;
                    }
                    int main() {
                        insertFirst("jyoti");
                        insertFirst("monika");
                        insertFirst("madhu");
                        insertFirst("savita");
                        insertLast(":)");
                        insertAtPos("hello",3);
                        display();
                        deleteLast();
                        display();
                        deleteFirst();
                        display();
                        deleteAtPos(3);
                        display();
                        sortList();
                        display();
                        int ans = search("madhu");
                        if(ans != -1){
                            printf("key is found at index : %d",ans);
                        }
                        else printf("NOt found\n");
                        return 0;
                    }
                    
              </pre>
              </div>
              <div class="output">
                <h1>OUTPUT</h1>
                <pre>

                  savita->madhu->hello->monika->jyoti->:)->NULL
                  savita->madhu->hello->monika->jyoti->NULL
                  madhu->hello->monika->jyoti->NULL
                  madhu->hello->jyoti->NULL
                  key is found at index : 1
                </pre>
              </div>
            </div>
            <div class="question">
              <div class="solve">
                <h2>Ques 6. IMPLEMENT THE OPERATIONS OF SINGLE CIRCULAR LINKED LIST STORING STRING VALUES (INSERT AT
                  BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL,
                  DISPLAY, SEARCH)</h2>
                <pre>
                  #include <stdio.h>
                    #include<stdlib.h>
                    #include <string.h>
                    struct LL{
                        char data[100];
                        struct LL *next;
                    };
                    struct LL *head = NULL;
                    struct LL *tail = NULL;
                    struct LL *newnode;
                    int size = 0;
                    
                    
                    void insertFirst(char str[]){
                        if(head == NULL){
                            head = (struct LL*)malloc(sizeof(struct LL));
                            //copy one string into another string
                            strcpy(head->data,str);
                            tail = head;
                            tail->next = NULL;
                            size++;
                            return;
                        }
                        newnode = (struct LL*)malloc(sizeof(struct LL));
                        strcpy(newnode->data,str);
                        newnode->next = head;
                        head = newnode;
                        size++;
                        return;
                    }
                    void insertLast(char str[]){
                        if(size == 0){
                            insertFirst(str);
                            return;
                        }
                        newnode = (struct LL*)malloc(sizeof(struct LL));
                        strcpy(newnode->data,str);
                        newnode->next = head;
                        tail->next = newnode;
                        tail = newnode;
                        size++;
                        return;
                    }
                    void insertAtPos(char str[],int pos){
                         if(pos == 0 || pos > size+1) {
                                printf("Invalid pos");
                                return;
                            }
                            if(pos == 1){
                                insertFirst(str);
                                return;
                            }
                             if(pos == size){
                               insertLast(str);
                               return;
                            }
                       newnode = (struct LL*)malloc(sizeof(struct LL));
                       if(newnode != NULL){
                           struct LL *prev = head;
                           for(int i = 1;i<pos-1;i++){
                               prev = prev->next;
                           }
                           strcpy(newnode->data,str);
                           newnode->next = prev->next;
                           prev->next = newnode;
                           size++;
                           return;
                       }else printf("LL is full\n");
                       
                    }
                    void display(){
                        struct LL *temp = head;
                        while(temp->next != head){
                            printf("%s->",temp->data);
                            temp = temp->next;
                        }
                        printf("NULL\n");
                    }
                    void deleteFirst(){
                        if(size == 0){
                            printf("LL is empty\n");
                            return;
                        }
                        if(size == 1){
                        head = tail = NULL;
                        size--;
                        return;
                        }
                        head = head->next;
                        size--;
                        return;
                    }
                    void deleteLast(){
                         if(size == 0){
                            printf("LL is empty\n");
                            return;
                        }
                        if(size == 1){
                        head = tail = NULL;
                        size--;
                        return;
                        }
                        struct LL *prev = head;
                        while(prev->next != tail){
                            prev = prev->next;
                        }
                        prev->next = head;
                        tail = prev;
                        size--;
                        return;
                    }
                    void deleteAtPos(int pos){
                            if(pos == 0) {
                                printf("Invalid pos!");
                                return ;
                            }
                            if(pos == 1) {
                                deleteFirst();
                                return ;
                            }
                            if(pos == size){
                                deleteLast();
                                return ;
                            }
                            if(pos > size){
                                printf("Invalid pos!");
                                return ;
                            }
                         struct LL *prev = head;
                         for(int i = 1;i<pos-1;i++){
                            prev = prev->next;
                        }
                        if(prev != NULL && prev->next != NULL){
                        prev->next = prev->next->next;
                        return;    
                    }
                    return;
                    }
                    void sortList(){
                        if(size == 0 || size == 1){
                            return;
                        }
                        for(int i = 0;i<size-1;i++){
                            struct LL *curr = head;
                        for(int j = 0;j<size-1;j++){
                            if(strcmp(curr->data,curr->next->data)>1){
                                char temp[100];
                                strcmp(temp,curr->data);
                                strcmp(curr->data,curr->next->data);
                                strcmp(curr->next->data,temp);
                            }
                            curr = curr->next;
                        }
                      }
                    }
                    int search(char str[]){
                        if(size == 0){
                            printf("LL is empty\n");
                            return 0;
                        }
                        struct LL *temp = head;
                        int index = 0;
                        while(temp != NULL){
                            if(strcmp(temp->data,str)==0){
                                return index;
                            }
                            temp = temp->next;
                            index++;
                        }
                        return -1;
                    }
                    int main() {
                        insertFirst("jyoti");
                        insertFirst("monika");
                        insertFirst("madhu");
                        insertFirst("savita");
                        insertLast(":)");
                        insertAtPos("hello",3);
                        display();
                        deleteLast();
                        display();
                        deleteFirst();
                        display();
                        deleteAtPos(3);
                        display();
                        sortList();
                        display();
                        int ans = search("hello");
                        if(ans != -1){
                            printf("key is found at index : %d",ans);
                        }else printf("NOt found\n");
                        return 0;
                    }
                  int main() {
                  int arr[5];
                  for(int i = 0;i < 5;i++){
                      printf(" Enter the value : ");
                      scanf("%d",&arr[i]);
                  }
                  for(int j =0;j < 5;j++){
                      printf("Yours values are : ");
                      printf("%d \n",arr[j]);
                  }
                  
                      return 0;
                  }
              </pre>
              </div>
              <div class="output">
                <h1>OUTPUT</h1>
                <pre>

                  savita->madhu->hello->monika->jyoti->NULL
                  savita->madhu->hello->monika->NULL
                  madhu->hello->monika->jyoti->NULL
                  madhu->hello->jyoti->NULL
                  madhu->hello->jyoti->NULL
                  key is found at index : 1
                </pre>
              </div>
            </div>
            <div class="question">
              <div class="solve">
                <h2>Ques 7. IMPLEMENT THE OPERATIONS OF DOUBLY LINKED LIST STORING STRING VALUES (INSERT AT BEGIN,INSERT
                  AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL, DISPLAY, SEARCH)
                </h2>
                <pre>

                  #include <stdio.h>
                    #include <stdlib.h>
                    #include <string.h>
                        
                        struct Node{
                            char data[100];
                            struct Node *next;
                            struct Node *prev;
                        };
                        
                        struct Node *head = NULL;
                        struct Node *tail = NULL;
                        
                        int size = 0;
                        
                        void insertFirst(char str[]){
                            if(head == NULL){
                                head = (struct Node*)malloc(sizeof(struct Node));
                                strcpy(head->data,str);
                                tail = head;
                                tail->next = NULL;
                                head->prev = NULL;
                                tail->prev = NULL;
                                size++;
                                return;
                            }
                            struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                            printf("%s",str);
                            strcpy(newNode->data,str);
                            newNode->next = head;
                            newNode->prev = NULL;
                            head = newNode;
                            size++;
                        }
                        
                        void insertLast(char str[]){
                            if(head == NULL){
                               insertFirst(str);
                                return;
                            }
                            struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                            strcpy(newNode->data,str);
                            newNode->next = NULL;
                            newNode->prev = tail;
                            tail->next = newNode;
                            tail = newNode;
                            size++;
                        }
                        
                        void insertInMiddle(char str[],int pos){
                            if(pos == 0) {
                                printf("Invalid pos");
                                return;
                            }
                            if(pos == 1){
                                insertFirst(str);
                                return;
                            }
                             if(pos == size){
                               insertLast(str);
                               return;
                            }
                        
                            if(pos > size+1){
                                printf("Invalid pos");
                                return;
                            }
                            struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                            if(newNode !=  NULL){
                              struct Node *prev = head;
                                for(int i = 1; i < pos-1;i++){
                                prev = prev->next;
                            }
                            strcpy(newNode->data,str);
                            newNode->next = prev->next;
                            prev->next->prev = newNode;
                            prev->next = newNode;
                            newNode->prev = prev;
                            size++;
                            }else {
                                printf("LinkedList is Full!");
                            }
                           
                        }
                        
                        void deleteFirst(){
                            if(size == 0){
                                printf("List is Empty!");
                                return;
                            }
                            if(size == 1){
                                head = tail = NULL;
                                size--;
                                return;
                            }
                            head = head->next;
                            head->prev = NULL;
                            size--;
                        }
                        void deleteLast(){
                             if(size == 0){
                                printf("List is Empty!");
                                return;
                            }
                            if(size == 1){
                                deleteFirst();
                                return;
                            }
                            struct Node *prev = head;
                            while(prev->next != tail){
                                prev = prev->next;
                            }
                            prev->next = NULL;
                            tail = prev;
                            size--;
                        }
                        
                        int search(char str[]){
                            if(size == 0){
                                printf("List is Empty!");
                                return -1; 
                            }
                            int indx = 0;
                            struct Node *temp = head;
                            while(temp != NULL){
                                if(strcmp(temp->data,str) == 0){
                                    return indx;
                                }
                                temp = temp->next;
                                indx++;
                            }
                            return -1;
                        }
                        
                        
                        void sortList(){
                            if(size == 0 || size == 1) return;
                            for(int i = 0; i < size-1;i++){
                                struct Node *cur = head;
                                for(int j = 0;j < size - 1 - i;j++){
                                    if(cur->next != NULL){
                                        if(strcmp(cur->data , cur->next->data) > 1){
                                            char temp[100];
                                            strcmp(temp,cur->data);
                                            strcpy(temp,cur->data);
                                            strcpy(cur->data,cur->next->data);
                                            strcpy( cur->next->data,temp);
                                        }
                                    }
                                    cur = cur->next;
                                }
                            }
                        }
                        
                        void deleteInMiddle(int pos){
                            if(pos == 0) {
                                printf("Invalid pos!");
                                return;
                            }
                            if(pos == 1) {
                                return deleteFirst();
                            }
                            if(pos == size){
                                deleteLast();
                                return ;
                            }
                            if(pos > size){
                                printf("Invalid pos!");
                                return ;
                            }
                            struct Node *temp = head;
                        
                            for(int i = 1; i < pos-1;i++){
                                temp = temp->next;
                            }
                            if(temp != NULL && temp->next != NULL){
                                temp->next = temp->next->next;
                                temp->next->next->prev = temp;
                            }
                        }
                        
                        void display(){
                            struct Node *temp = head;
                            while(temp != NULL){
                                printf("%s<->",temp->data);
                                temp = temp->next;
                            }
                            printf("null");
                        }
                        
                        void main(){
                            insertFirst("hy");
                            insertLast("Hello");
                            insertLast("Faham");
                            insertInMiddle(":)",2);
                            display();
                        }
                       
              </pre>
              </div>
              <div class="output">
                <h1>OUTPUT</h1>
                <pre>

                  hy<->:)<->Hello<->Faham<->null 
                </pre>
              </div>
            </div>
            <div class="question">
              <div class="solve">
                <h2>Ques 8. IMPLEMENT THE OPERATIONS OF DOUBLY CIRCULAR LINKED LIST STORING STRING VALUES (INSERT AT
                  BEGIN,INSERT AT POS,INSERT AT END,DELETE AT BEGIN,DELETE AT END, DELETE AT POS, ISEMPTY, ISFULL,
                  DISPLAY, SEARCH)</h2>
                <pre>


#include < stdio.h>
  #include < stdlib.h>
  #include < string.h>
      
      struct Node{
          char data[100];
          struct Node *next;
          struct Node *prev;
      };
      
      struct Node *head = NULL;
      struct Node *tail = NULL;
      
      int size = 0;
      
      void insertFirst(char str[]){
          if(head == NULL){
              head = (struct Node*)malloc(sizeof(struct Node));
              strcpy(head->data,str);
              tail = head;
              tail->next = NULL;
              head->prev = NULL;
              tail->prev = NULL;
              size++;
              return;
          }
          struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
          printf("%s",str);
          strcpy(newNode->data,str);
          newNode->next = head;
          newNode->prev = NULL;
          head = newNode;
          size++;
      }
      
      void insertLast(char str[]){
          if(head == NULL){
             insertFirst(str);
              return;
          }
          struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
          strcpy(newNode->data,str);
          newNode->next = head;
          newNode->prev = tail;
          tail->next = newNode;
          tail = newNode;
          size++;
      }
      
      void insertInMiddle(char str[],int pos){
          if(pos == 0) {
              printf("Invalid pos");
              return;
          }
          if(pos == 1){
              insertFirst(str);
              return;
          }
           if(pos == size){
             insertLast(str);
             return;
          }
      
          if(pos > size+1){
              printf("Invalid pos");
              return;
          }
          struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
          if(newNode !=  NULL){
            struct Node *prev = head;
              for(int i = 1; i < pos-1;i++){
              prev = prev->next;
          }
          strcpy(newNode->data,str);
          newNode->next = prev->next;
          prev->next->prev = newNode;
          prev->next = newNode;
          newNode->prev = prev;
          size++;
          }else {
              printf("LinkedList is Full!");
          }
         
      }
      
      void deleteFirst(){
          if(size == 0){
              printf("List is Empty!");
              return;
          }
          if(size == 1){
              head = tail = NULL;
              size--;
              return;
          }
          head = head->next;
          head->prev = NULL;
          size--;
      }
      void deleteLast(){
           if(size == 0){
              printf("List is Empty!");
              return;
          }
          if(size == 1){
              deleteFirst();
              return;
          }
          struct Node *prev = head;
          while(prev->next != tail){
              prev = prev->next;
          }
          prev->next = NULL;
          tail = prev;
          size--;
      }
      
      int search(char str[]){
          if(size == 0){
              printf("List is Empty!");
              return -1; 
          }
          int indx = 0;
          struct Node *temp = head;
          while(temp != NULL){
              if(strcmp(temp->data,str) == 0){
                  return indx;
              }
              temp = temp->next;
              indx++;
          }
          return -1;
      }
      
      
      void sortList(){
          if(size == 0 || size == 1) return;
          for(int i = 0; i < size-1;i++){
              struct Node *cur = head;
              for(int j = 0;j < size - 1 - i;j++){
                  if(cur->next != NULL){
                      if(strcmp(cur->data , cur->next->data) > 1){
                          char temp[100];
                          strcmp(temp,cur->data);
                          strcpy(temp,cur->data);
                          strcpy(cur->data,cur->next->data);
                          strcpy( cur->next->data,temp);
                      }
                  }
                  cur = cur->next;
              }
          }
      }
      
      void deleteInMiddle(int pos){
          if(pos == 0) {
              printf("Invalid pos!");
              return;
          }
          if(pos == 1) {
              return deleteFirst();
          }
          if(pos == size){
              deleteLast();
              return ;
          }
          if(pos > size){
              printf("Invalid pos!");
              return ;
          }
          struct Node *temp = head;
      
          for(int i = 1; i < pos-1;i++){
              temp = temp->next;
          }
          if(temp != NULL && temp->next != NULL){
              temp->next = temp->next->next;
              temp->next->next->prev = temp;
          }
      }
      
      void display(){
        if(size == 0)printf("LL is empty\n");
        struct Node *temp = head;
        do{
            printf("%s<->",temp->data); 
            temp = temp->next;
        }
        while(temp != head);
         printf("null");
    }
      
      void main(){
          insertFirst("hy");
          insertLast("Hello");
          insertLast("Faham");
          insertInMiddle(":)",2);
          display();
      }
              </pre>
              </div>
              <div class="output">
                <h1>OUTPUT</h1>
                <pre>
                  hy<->:)<->Hello<->Faham<->null
                </pre>
              </div>
            </div>
            <div class="question">
              <div class="solve">
                <h2>Ques 9. ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, ADD THEM AND DISPLAY THE ANSWER.</h2>
                <pre>

                  #include < stdio.h>
                    #include < stdlib.h>
                    #include < math.h>
                        
                        struct Node{
                            int coffe;
                            int pow;
                            struct Node *next;
                        };
                        
                        struct Node *head = NULL;
                        struct Node *tail = NULL;
                        
                        int size = 0;
                        
                        void insertFirst(int val,int pow){
                            if(head == NULL){
                                head = (struct Node*)malloc(sizeof(struct Node));
                                head->coffe = val;
                                head->pow = pow;
                                tail = head;
                                tail->next = NULL;
                                size++;
                                return;
                            }
                            struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                            newNode->coffe = val;
                            newNode->pow = pow;
                            newNode->next = head;
                            head = newNode;
                            size++;
                        }
                        
                        void insertLast(int val,int pow){
                            if(head == NULL){
                               insertFirst(val,pow);
                                return;
                            }
                            struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                            newNode->coffe = val;
                            newNode->pow = pow;
                            newNode->next = NULL;
                            tail->next = newNode;
                            tail = newNode;
                            size++;
                        }
                        
                        void insertInMiddle(int val,int pow,int pos){
                            if(pos == 0) {
                                printf("Invalid pos");
                                return;
                            }
                            if(pos == 1){
                                insertFirst(val,pow);
                                return;
                            }
                             if(pos == size){
                               insertLast(val,pow);
                               return;
                            }
                        
                            if(pos > size+1){
                                printf("Invalid pos");
                                return;
                            }
                            struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                            if(newNode !=  NULL){
                              struct Node *prev = head;
                                for(int i = 1; i < pos-1;i++){
                                prev = prev->next;
                            }
                            newNode->coffe = val;
                            newNode->pow = pow;
                            newNode->next = prev->next;
                            prev->next = newNode;
                            size++;
                            }else {
                                printf("LinkedList is Full!");
                            }
                           
                        }
                        
                        int deleteFirst(){
                            if(size == 0){
                                printf("List is Empty!");
                                return -1;
                            }
                            int coffe = head->coffe;
                            if(size == 1){
                                head = tail = NULL;
                                size--;
                                return coffe;
                            }
                            head = head->next;
                            size--;
                            return coffe;
                        }
                        
                        int deleteLast(){
                             if(size == 0){
                                printf("List is Empty!");
                                return -1;
                            }
                            if(size == 1){
                                return deleteFirst();
                            }
                            struct Node *prev = head;
                            while(prev->next != tail){
                                prev = prev->next;
                            }
                            int coffe = tail->coffe;
                            prev->next = NULL;
                            tail = prev;
                            size--;
                            return coffe;
                        }
                        
                        int deleteInMiddle(int pos){
                            if(pos == 0) {
                                printf("Invalid pos!");
                                return -1;
                            }
                            if(pos == 1) {
                                return deleteFirst();
                            }
                            if(pos == size){
                                return deleteLast();
                            }
                            if(pos > size){
                                printf("Invalid pos!");
                                return -1;
                            }
                            struct Node *temp = head;
                        
                            for(int i = 1; i < pos - 1;i++){
                                temp = temp->next;
                            }
                            if(temp != NULL && temp->next != NULL){
                                int coffe = temp->next->coffe;
                                temp->next = temp->next->next;
                                return coffe;
                            }
                            return -1;
                        }
                        
                        void display(char var){
                            struct Node *temp = head;
                            while(temp != NULL){
                                printf("(%d%c^%d) + ",temp->coffe,var,temp->pow);
                                temp = temp->next;
                            }
                            printf("0\n");
                        }
                        
                        
                    
                        
                        int calcEqn(int x){
                            int sum = 0;
                            struct Node *temp = head;
                            sum += temp->coffe * pow(x,temp->pow);
                            temp = temp->next;
                            while(temp != NULL){
                                sum *= temp->coffe * pow(x,temp->pow);
                                temp = temp->next;
                            }
                            return sum;
                        }
                        
                        void main(){
                            insertLast(2,2);
                            insertLast(3,1);
                            insertLast(5,0);
                            display('x');
                            printf("Ans of polynomial is : %d",calcEqn(1));
                        }
              </pre>
              </div>
              <div class="output">
                <h1>OUTPUT</h1>
                <pre>

                  (2x^2) + (3x^1) + (5x^0) + 0
                  Ans of polynomial is : 30
                </pre>
              </div>
            </div>
            <div class="question">
              <div class="solve">
                <h2>Ques 10. ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, SUBTRACT THEM AND DISPLAY THE ANSWER.</h2>
                <pre>
                  #include <stdio.h>
                    #include <stdlib.h>
                    #include <math.h>
                    
                    struct Node{
                        int coffe;
                        int pow;
                        struct Node *next;
                    };
                    
                    struct Node *head = NULL;
                    struct Node *tail = NULL;
                    
                    int size = 0;
                    
                    void insertFirst(int val,int pow){
                        if(head == NULL){
                            head = (struct Node*)malloc(sizeof(struct Node));
                            head->coffe = val;
                            head->pow = pow;
                            tail = head;
                            tail->next = NULL;
                            size++;
                            return;
                        }
                        struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                        newNode->coffe = val;
                        newNode->pow = pow;
                        newNode->next = head;
                        head = newNode;
                        size++;
                    }
                    
                    void insertLast(int val,int pow){
                        if(head == NULL){
                           insertFirst(val,pow);
                            return;
                        }
                        struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                        newNode->coffe = val;
                        newNode->pow = pow;
                        newNode->next = NULL;
                        tail->next = newNode;
                        tail = newNode;
                        size++;
                    }
                    
                    void insertInMiddle(int val,int pow,int pos){
                        if(pos == 0) {
                            printf("Invalid pos");
                            return;
                        }
                        if(pos == 1){
                            insertFirst(val,pow);
                            return;
                        }
                         if(pos == size){
                           insertLast(val,pow);
                           return;
                        }
                    
                        if(pos > size+1){
                            printf("Invalid pos");
                            return;
                        }
                        struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                        if(newNode !=  NULL){
                          struct Node *prev = head;
                            for(int i = 1; i < pos-1;i++){
                            prev = prev->next;
                        }
                        newNode->coffe = val;
                        newNode->pow = pow;
                        newNode->next = prev->next;
                        prev->next = newNode;
                        size++;
                        }else {
                            printf("LinkedList is Full!");
                        }
                       
                    }
                    
                    int deleteFirst(){
                        if(size == 0){
                            printf("List is Empty!");
                            return -1;
                        }
                        int coffe = head->coffe;
                        if(size == 1){
                            head = tail = NULL;
                            size--;
                            return coffe;
                        }
                        head = head->next;
                        size--;
                        return coffe;
                    }
                    
                    int deleteLast(){
                         if(size == 0){
                            printf("List is Empty!");
                            return -1;
                        }
                        if(size == 1){
                            return deleteFirst();
                        }
                        struct Node *prev = head;
                        while(prev->next != tail){
                            prev = prev->next;
                        }
                        int coffe = tail->coffe;
                        prev->next = NULL;
                        tail = prev;
                        size--;
                        return coffe;
                    }
                    
                    int deleteInMiddle(int pos){
                        if(pos == 0) {
                            printf("Invalid pos!");
                            return -1;
                        }
                        if(pos == 1) {
                            return deleteFirst();
                        }
                        if(pos == size){
                            return deleteLast();
                        }
                        if(pos > size){
                            printf("Invalid pos!");
                            return -1;
                        }
                        struct Node *temp = head;
                    
                        for(int i = 1; i < pos - 1;i++){
                            temp = temp->next;
                        }
                        if(temp != NULL && temp->next != NULL){
                            int coffe = temp->next->coffe;
                            temp->next = temp->next->next;
                            return coffe;
                        }
                        return -1;
                    }
                    
                    void display(char var){
                        struct Node *temp = head;
                        while(temp != NULL){
                            printf("(%d%c^%d) + ",temp->coffe,var,temp->pow);
                            temp = temp->next;
                        }
                        printf("0");
                    }
                    
                    
                
                    
                    int calcEqn(int x){
                        int sum = 0;
                        struct Node *temp = head;
                        sum += temp->coffe * pow(x,temp->pow);
                        temp = temp->next;
                        while(temp != NULL){
                            sum -= temp->coffe * pow(x,temp->pow);
                            temp = temp->next;
                        }
                        return sum;
                    }
                    
                    void main(){
                        insertLast(2,2);
                        insertLast(3,1);
                        insertLast(-5,0);
                        display('x');
                        printf("
                Ans of polynomial is : %d",calcEqn(2));
                    }
                  
           
                
              
              </pre>
              </div>
              <div class="output">
                <h1>OUTPUT</h1>
                <pre>

                 (2x^2) + (3x^1) + (-5x^0) + 0
                  Ans of polynomial is : 7
               
                </pre>
              </div>
            </div>
            <div class="question">
              <div class="solve">
                <h2>Ques 11. ENTER THE 2 POLYNOMIAL EQUATIONS DYNAMICALLY, MULTIPLY THEM AND DISPLAY THE ANSWER.</h2>
                <pre>
                  #include <stdio.h>
                    #include <stdlib.h>
                    #include <math.h>
                    
                    struct Node{
                        int coffe;
                        int pow;
                        struct Node *next;
                    };
                    
                    struct Node *head = NULL;
                    struct Node *tail = NULL;
                    
                    int size = 0;
                    
                    void insertFirst(int val,int pow){
                        if(head == NULL){
                            head = (struct Node*)malloc(sizeof(struct Node));
                            head->coffe = val;
                            head->pow = pow;
                            tail = head;
                            tail->next = NULL;
                            size++;
                            return;
                        }
                        struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                        newNode->coffe = val;
                        newNode->pow = pow;
                        newNode->next = head;
                        head = newNode;
                        size++;
                    }
                    
                    void insertLast(int val,int pow){
                        if(head == NULL){
                           insertFirst(val,pow);
                            return;
                        }
                        struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                        newNode->coffe = val;
                        newNode->pow = pow;
                        newNode->next = NULL;
                        tail->next = newNode;
                        tail = newNode;
                        size++;
                    }
                    
                    void insertInMiddle(int val,int pow,int pos){
                        if(pos == 0) {
                            printf("Invalid pos");
                            return;
                        }
                        if(pos == 1){
                            insertFirst(val,pow);
                            return;
                        }
                         if(pos == size){
                           insertLast(val,pow);
                           return;
                        }
                    
                        if(pos > size+1){
                            printf("Invalid pos");
                            return;
                        }
                        struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
                        if(newNode !=  NULL){
                          struct Node *prev = head;
                            for(int i = 1; i < pos-1;i++){
                            prev = prev->next;
                        }
                        newNode->coffe = val;
                        newNode->pow = pow;
                        newNode->next = prev->next;
                        prev->next = newNode;
                        size++;
                        }else {
                            printf("LinkedList is Full!");
                        }
                       
                    }
                    
                    int deleteFirst(){
                        if(size == 0){
                            printf("List is Empty!");
                            return -1;
                        }
                        int coffe = head->coffe;
                        if(size == 1){
                            head = tail = NULL;
                            size--;
                            return coffe;
                        }
                        head = head->next;
                        size--;
                        return coffe;
                    }
                    
                    int deleteLast(){
                         if(size == 0){
                            printf("List is Empty!");
                            return -1;
                        }
                        if(size == 1){
                            return deleteFirst();
                        }
                        struct Node *prev = head;
                        while(prev->next != tail){
                            prev = prev->next;
                        }
                        int coffe = tail->coffe;
                        prev->next = NULL;
                        tail = prev;
                        size--;
                        return coffe;
                    }
                    
                    int deleteInMiddle(int pos){
                        if(pos == 0) {
                            printf("Invalid pos!");
                            return -1;
                        }
                        if(pos == 1) {
                            return deleteFirst();
                        }
                        if(pos == size){
                            return deleteLast();
                        }
                        if(pos > size){
                            printf("Invalid pos!");
                            return -1;
                        }
                        struct Node *temp = head;
                    
                        for(int i = 1; i < pos - 1;i++){
                            temp = temp->next;
                        }
                        if(temp != NULL && temp->next != NULL){
                            int coffe = temp->next->coffe;
                            temp->next = temp->next->next;
                            return coffe;
                        }
                        return -1;
                    }
                    
                    void display(char var){
                        struct Node *temp = head;
                        while(temp != NULL){
                            printf("(%d%c^%d) + ",temp->coffe,var,temp->pow);
                            temp = temp->next;
                        }
                        printf("0");
                    }
                    
                    
                
                    
                    int calcEqn(int x){
                        int sum = 0;
                        struct Node *temp = head;
                        sum += temp->coffe * pow(x,temp->pow);
                        temp = temp->next;
                        while(temp != NULL){
                            sum *= temp->coffe * pow(x,temp->pow);
                            temp = temp->next;
                        }
                        return sum;
                    }
                    
                    void main(){
                        insertLast(2,2);
                        insertLast(3,1);
                        insertLast(-5,0);
                        printf("
                Ans of polynomial is : %d",calcEqn(2));
                    }
                  
              
             
              </pre>
              </div>
              <div class="output">
                <h1>OUTPUT</h1>
                <pre>

                  Ans of polynomial is : -240  
                </pre>
              </div>
            </div>
            <!---------------------------------TREE---------------------------------------------->
            <section id="tree">
              <h1>TREE</h1>
              <div class="question">
                <div class="solve">
                  <h2>Ques 1. CONSTRUCT BINARY TREE FROM PREORDER AND INORDER TRAVERSAL</h2>
                  <pre>
#include < stdio.h>
  #include < stdlib.h>
  
  struct Node{
      int data;
      struct Node *left;
      struct Node *right;
  };
  int indx = 0;
  struct Node *root;
  int findElem(int in[],int n,int elem){
      for(int i = 0;i < n;i++){
          if(in[i] == elem) return i;
      }
      return -1;
  }
  
  struct Node* buildTree(int in[],int pre[],int inOrderStart,int inOrderEnd,int n){
      // base case.
      if(inOrderStart > inOrderEnd || indx >= n) return NULL;
  
      struct Node *root = (struct Node*)malloc(sizeof(struct Node));
      int elem = pre[indx++];
      root->data = elem;
      int pos = findElem(in,n,elem);
      if(pos == -1) {
          printf("Invalid input !");
          return NULL;
      }
      root->left = buildTree(in,pre,inOrderStart,pos-1,n);
      root->right = buildTree(in,pre,pos + 1,inOrderEnd,n);
      return root;
  }
  
  
  void preorder(struct Node *node){
   if(node == NULL){
      return;
   }
   printf("%d ",node->data);
   preorder(node->left);
   preorder(node->right);
  }
  
  void main(){
      int in[] = {3,1,4,0,5,2};
      int pre[] = {0,1,3,4,2,5};
      int n = sizeof(in)/sizeof(int);
      root = buildTree(in,pre,0,n-1,n);
      printf("Preorder of build tree is : ");
      preorder(root);
  }

   </pre>
                </div>
                <div class="output">
                  <h1>OUTPUT</h1>
                  <pre>
Preorder of build tree is :
 0 1 3 4 2 5
     </pre>
                </div>
              </div>
              <div class="question">
                <div class="solve">
                  <h2>Ques 2.Construct a binary tree from inorder and postorder.</h2>
                  <pre>
    #include < stdio.h>
    #include < stdlib.h>

    struct Node{
    int data;
    struct Node *left;
    struct Node *right;
    };
    int indx;
    struct Node *root;
    int findElem(int in[],int n,int elem){

    for(int i = 0;i < n;i++){ 
    if(in[i]==elem){ 
    return i;
    }
     return -1; 
    } 
                        
   struct Node* buildTree(int
   in[],int post[],int inOrderStart,int inOrderEnd,int n){

    // base case. 
   if(inOrderStart>inOrderEnd || indx < 0)
   return NULL; 
   struct Node *root=(struct Node*)malloc(sizeof(structNode));
   int elem=post[indx--]; root->data = elem;
   int pos = findElem(in,n,elem);
   if(pos == -1) {
   printf("Invalid input !");
   return NULL;
   }
   root->right = buildTree(in,post,pos + 1,inOrderEnd,n);
   root->left = buildTree(in,post,inOrderStart,pos-1,n);
   return root;
   }


  void preorder(struct Node *node){
  if(node == NULL){
  return;
  }
  printf("%d ",node->data);
  preorder(node->left);
  preorder(node->right);
  }

  void main(){
  int in[] = {4,8,2,5,1,6,3,7};
  int post[] = {8,4,5,2,6,7,3,1};
  int n = sizeof(in)/sizeof(int);
  indx = n-1;
  root = buildTree(in,post,0,n-1,n);
  printf("Preorder of build tree is : ");
  preorder(root);
  }
                          </pre>
                </div>
                <div class="output">
                  <h1>OUTPUT</h1>
                  <pre>





Preorder of build tree is :
 1 2 4 8 5 3 6 7 
     </pre>
                </div>
              </div>
              <div class="question">
                <div class="solve">
                  <h2>Ques 3. PRINT LEFT VIEW OF BINARY TREE</h2>
                  <pre>
     #include < stdio.h>
     #include < stdlib.h>

     struct TNode{
         int data;
         int level;
         struct TNode *left;
         struct TNode *right;
     };
     void updateLevel(struct TNode *node,int level){
         if(node == NULL){
            return;
         }
         node->level = level;
         updateLevel(node->left,level+1);
         updateLevel(node->right,level+1);
        }
     
     void leftView(struct TNode *root){
         int level = 1;
         add(root);
         add(NULL);
         while(!isQEmpty()){
             struct TNode *cur = remove1();
             if(cur == NULL){
                 if(isQEmpty() == 1) break;
                 else {
                     add(NULL);
                 }
             }else {
                 if(cur->level == level) {
                     printf("%d ",cur->data);
                     level++;
                 }
                 if(cur->left != NULL) add(cur->left);
                 if(cur->right != NULL) add(cur->right);
             }
         }
     }
     void main(){
         int in[] =  {4,8,2,5,1,6,3,7};
         int post[] = {8,4,5,2,6,7,3,1};
         int n = sizeof(in)/sizeof(int);
         indx = n-1;
         root = buildTree(in,post,0,n-1,n);
         updateLevel(root,1);
         leftView(root);
     }
  </pre>
                </div>
                <div class="output">
                  <h1>OUTPUT</h1>
                  <pre>


    1 2 4 8
     </pre>
                </div>
              </div>
              <div class="question">
                <div class="solve">
                  <h2>Ques 4. DISPLAY THE RIGHT VIEW OF BINARY TREE</h2>
                  <pre>

     #include < stdio.h>
     #include < stdlib.h>

     struct TNode{
         int data;
         int level;
         struct TNode *left;
         struct TNode *right;
     };
     void updateLevel(struct TNode *node,int level){
         if(node == NULL){
            return;
         }
         node->level = level;
         updateLevel(node->left,level+1);
         updateLevel(node->right,level+1);
        }
     
        //4. PRINT RIGHT VIEW OF BINARY TREE
        void rightView(struct TNode *root){
            int level = 1;
            add(root);
            add(NULL);
            while(!isQEmpty()){
                struct TNode *cur = remove1();
                if(cur == NULL){
                    if(isQEmpty() == 1) break;
                    else {
                        add(NULL);
                    }
                }else {
                    if(cur->level == level) {
                        printf("%d ",cur->data);
                        level++;
                    }
                    if(cur->right != NULL) add(cur->right);
                    if(cur->left != NULL) add(cur->left);
                }
            }
        }
        
     void main()
         int in[] =  {4,8,2,5,1,6,3,7};
         int post[] = {8,4,5,2,6,7,3,1};
         int n = sizeof(in)/sizeof(int);
         indx = n-1;
         root = buildTree(in,post,0,n-1,n);
         updateLevel(root,1);
         rightView(root);
                          
                    
   </pre>
                </div>
                <div class="output">
                  <h1>OUTPUT</h1>
                  <pre>

     1 3 7 8 
     </pre>
                </div>
              </div>
              <div class="question">
                <div class="solve">
                  <h2>Ques 5. Level order traversal on a Binary Tree</h2>
                  <pre>
        #include < stdio.h>
        #include < stdlib.h>
        
        struct QNode {
            struct TNode *data;
            struct QNode *next;
        };
        
        struct QNode *front = NULL,*rear = NULL;
        int Qsize = 0;
        int isEmpty(){
            if(Qsize == 0){
                return 1;
            }
            return 0;
        }
        void add(struct TNode *val){
            if(rear == NULL){
                rear = (struct QNode*)malloc((sizeof(struct QNode)));
                rear->data = val;
                rear->next = NULL;
                front = rear;
                Qsize++;
                return;
            }
            struct QNode *temp = (struct QNode*)malloc((sizeof(struct QNode)));
            if(temp == NULL){
                printf("Queue if FULL!");
                return;
            }
            temp->data = val;
            temp->next = NULL;
            rear->next = temp;
            rear = temp;
            Qsize++;
        }
        
        struct TNode* remove1(){
            if(Qsize == 0){
                printf("Queue is Empty!");
                return NULL;
            }
            struct TNode *val = front->data;
            struct QNode *temp = front;
            front = front->next;
            free(temp);
            Qsize--;
            return val;
        }
        
        struct TNode* peek(){
            if(front == NULL){
                printf("Queue is Empty!");
                return NULL;
            }
            return front->data; 
        }
        int isQEmpty(){
            if(Qsize == 0) return 1;
            return 0;
        }
        void levelOrder(struct TNode *root){
            add(root);
            add(NULL);
            while(!isQEmpty()){
                struct TNode *cur = remove1();
                if(cur == NULL){
                    if(isQEmpty() == 1) break;
                    else {
                        add(NULL);
                    }
                }else {
                    printf("%d ",cur->data);
                    if(cur->left != NULL) add(cur->left);
                    if(cur->right != NULL) add(cur->right);
                }
            }
        
        }
        
        
        void main(){
            int in[] =  {4,8,2,5,1,6,3,7};
            int post[] = {8,4,5,2,6,7,3,1};
            int n = sizeof(in)/sizeof(int);
            indx = n-1;
            root = buildTree(in,post,0,n-1,n);
            levelOrder(root);
        }
      
  </pre>
                </div>
                <div class="output">
                  <h1>OUTPUT</h1>
                  <pre>
      1 2 3 4 5 6 7 8 
    </pre>
                </div>
              </div>
              <div class="question">
                <div class="solve">
                  <h2>Ques 6. FIND THE MAXIMUM DEPTH OF BINARY TREE</h2>
                  <pre>
        #include < stdio.h>
         #include < stdlib.h>
         int getMax(int a,int b){
           if(a > b) return a;
           return b;
     }
       int maxDepth(struct TNode *root){
           if(root == NULL) return 0;
           int left = maxDepth(root->left);
           int right = maxDepth(root->right);
           return getMax(left,right) + 1;
     }


       void main(){
           int in[] =  {4,8,2,5,1,6,3,7};
           int post[] = {8,4,5,2,6,7,3,1};
           int n = sizeof(in)/sizeof(int);
           indx = n-1;
           root = buildTree(in,post,0,n-1,n);
           updateLevel(root,1);
           printf("Maximum depth of Binary Tree is : %d",maxDepth(root));
     }


   </pre>
                </div>
                <div class="output">
                  <h1>OUTPUT</h1>
                  <pre>
         Maximum depth of Binary Tree is : 4 
       </pre>
                </div>
              </div>
              <div class="question">
                <div class="solve">
                  <h2>Ques 7. CREATE BINARY SEARCH TREE USING ARRAYS (INSERT, DELETE, SEARCH, PREORDER, INORDER,
                    POSTORDER, MINIMUM ELEMENT)</h2>
                  <pre>

       #include < stdio.h>
         #define MAX 30
         
         int tree[MAX];
         int size = 0;
         
         void insert(int val){
             if(size == MAX){
                 printf("Tree is Full!");
                 return;
             }
             // add root value.
             if(size == 0){
                 tree[0] = val;
                 size++;
                 return;
            }
            int i = 0;
            // getting correct index.
            while(i < MAX && tree[i] != -1){
             if(val < tree[i]){
                 i = 2*i + 1;
             }else if(val > tree[i]){
                 i = 2*i + 2;
             }else {
                 printf("Duplicate is not allowed!");
                 break;
             }
           }
           if(i < MAX){
             tree[i] = val;
             size++;
           }else {
             printf("Tree is Full!");
             return;
           }
         }
         
         int delete(int val){
             if(size == 0){
                 printf("Tree is Empty!");
                 return -1;
             }
             if(size == 1){
                 size = 0;
                 return 0;
             }
              int i = 0;
            // getting correct index.
            while(i < MAX && tree[i] != -1){
             if(tree[i] == val){
                 break;
             }
             if(val < tree[i]){
                 i = 2*i + 1;
             }else if(val > tree[i]){
                 i = 2*i + 2;
             }
           }
           if(i < MAX && tree[i] != -1){
             size--;
             int val = tree[i];
             tree[i] = -1;
             return i;
           }else {
             printf("Value not found!");
             return -1;
           }
         
         }
         
         
         int search(int val){
             if(size == 0){
                 printf("Tree is Empty!");
                 return -1;
             }
              int i = 0;
            // getting correct index.
            while(i < MAX && tree[i] != -1){
             if(tree[i] == val){
                 break;
             }
             if(val < tree[i]){
                 i = 2*i + 1;
             }else if(val > tree[i]){
                 i = 2*i + 2;
             }
           }
           if(i < MAX && tree[i] != -1){
             return i;
           }else {
             printf("Value not found!");
             return -1;
           }
         }
         
         
         void preOrder(int index){
          if(index >= MAX || index < 0){
             return;
          }
          printf("%d ",tree[index]);
          int leftIndx = 2*index + 1;
          int rightIndx = 2*index + 2;
          if(tree[leftIndx] != -1) preOrder(leftIndx);
          if(tree[rightIndx] != -1) preOrder(rightIndx);
         }
         
         void inOrder(int index){
          if(index >= MAX || index < 0){
             return;
          }
          int leftIndx = 2*index + 1;
          int rightIndx = 2*index + 2;
          if(tree[leftIndx] != -1) inOrder(leftIndx);
          printf("%d ",tree[index]);
          if(tree[rightIndx] != -1) inOrder(rightIndx);
         }
         
         void postOrder(int index){
          if(index >= MAX || index < 0){
             return;
          }
          int leftIndx = 2*index + 1;
          int rightIndx = 2*index + 2;
          if(tree[leftIndx] != -1) postOrder(leftIndx);
          if(tree[rightIndx] != -1) postOrder(rightIndx);
          printf("%d ",tree[index]);
         }
         
         int getMin(){
             if(size == 0){
                 return -1;
             }
             int i = 0;
             int prev = -1;
              // getting correct index.
            while(i < MAX && tree[i] != -1){
                 prev = i;
                 i = 2*i + 1;
           }
           if(prev < MAX) return tree[prev];
         }
         
         void main(){
           for(int i = 0;i < MAX;i++){
             tree[i] = -1;
           }
           insert(100);
           insert(80);
           insert(85);
           insert(70);
           insert(110);
           insert(50);
           insert(40);
           insert(105);
           insert(120);
           delete(70);
           insert(10)
           printf("Key Found At Index : %d ",search(60));
           printf(" Min : %d ",getMin());
                        printf("PreOrder : ");
                        preOrder(0);
                        printf("Inorder : ");
                        inOrder(0);
                        printf("PostOrder : ");
                        postOrder(0);
                        printf("\n");
                       
                      }
                    </pre>
                </div>
                <div class="output">
                  <h1>OUTPUT</h1>
                  <pre>
 Key Found At Inde
 Min : 40
 
 PreOrder : 100 80 60 50 40 85 110 105 120  
 Inorder : 40 50 60 80 85 100 105 110 120   
 PostOrder : 40 50 60 85 80 105 120 110 100 
           </pre>
                </div>
              </div>
              <div class="question">
                <div class="solve">
                  <h2>Ques 8. CREATE BINARY SEARCH TREE DYNAMICALLY (INSERT, DELETE, SEARCH, PREORDER, INORDER,
                    POSTORDER, MINIMUM ELEMENT)</h2>
                  <pre>


    #include < stdio.h>
    #include < stdlib.h>
   
    struct Tree{
        int data;
        struct Tree *left;
        struct Tree *right;
    };
    struct Tree *root = NULL,*newNode,*search,*prevSearch;
    void insert(int val){
        if(root == NULL){
            root = (struct Tree*)malloc(sizeof(struct Tree));
            root->data = val;
            root->left = NULL;
            root->right = NULL;
            return;
        }
        newNode = (struct Tree*)malloc(sizeof(struct Tree));
        if(newNode != NULL){
            prevSearch  = NULL;
            search = root;
            while(search != NULL){
                if(search->data > val){
                    prevSearch = search;
                    search = search->left;
                }else if(search->data < val){
                    prevSearch = search;
                    search = search->right;
                }else {
                    printf("Duplicate is not allowed!");
                    return;
                }
            }
             // inserting the node 
            if(prevSearch->data > val){
                prevSearch->left =  newNode;
                prevSearch->left->data = val;
              }
            if(prevSearch->data < val){
                prevSearch->right = newNode;
                prevSearch->right->data = val;
            }
            newNode->left = NULL;
            newNode->right = NULL;
        }
    }
    
    struct Tree *prevIS = NULL;
    struct Tree* findInorderSuccessor(struct Tree *node){
        if(node == NULL){
            return node;
        }
        while(node->left != NULL){
            prevIS = node;
            node = node->left;
        }
        return node;
    }
    
    int delete(int val){
        prevSearch = NULL;
        search = root;
        while(search != NULL){
            // search left move krega
            if(search->data > val){
                prevSearch = search;
                search = search->left;
            // search right move krega
            }else if(search->data < val){
                prevSearch = search;
                search = search->right;
            }else { // search eqaul hai value k
                // no child node.
                if(search->left == NULL && search->right == NULL){
                    if(prevSearch->data > val){
                        prevSearch->left = NULL;
                    }else if(prevSearch->data < val){
                        prevSearch->right = NULL;
                    }
                }
                // one-child node.
                if(search->left == NULL || search->right == NULL){
                    if(prevSearch->data > val){
                        // left side
                        if(search->left == NULL){
                            prevSearch->left = search->right;
                        }else{
                            prevSearch->left = search->left;
                        }
                    }else {
                        // right side
                         if(search->left == NULL){
                            prevSearch->right = search->right;
                        }else{
                            prevSearch->right = search->left;
                        }
                    }
                }
               // 2 child  
                if(search->left != NULL && search->right != NULL){
                //1. find successor.
                struct Tree *IS = findInorderSuccessor(search->right);
                //2. swap data of succsessor with node to be deleetd.
                 search->data = IS->data;
                //3. delete succsessor.
                prevIS->left = NULL;
            }
                break;
            }
        }
    }
    
    int searchFunc(int val){
        if(root == NULL){
            return 0;
        }
        search = root;
        while(search != NULL){
            if(search->data == val){
                return 1;
            }
            if(search->data > val){
                search = search->left;
            }else {
                search = search->right;
            }
        }
        return 0;
    }
    
    void preorder(struct Tree *node){
        if(node == NULL){
            return;
        }
        printf("%d ",node->data);
        preorder(node->left);
        preorder(node->right);
    }
    void inOrder(struct Tree *node){
        if(node == NULL){
            return;
        }
        inOrder(node->left);
        printf("%d ",node->data);
        inOrder(node->right);
    }
    void postOrder(struct Tree *node){
        if(node == NULL){
            return;
        }
        postOrder(node->left);
        postOrder(node->right);
        printf("%d ",node->data);
    }
    
    int getMin(){
        if(root == NULL){
            return -1;
        }
        search = root;
        while(search != NULL){
            prevSearch = search;
            search = search->left;
        }
        return prevSearch->data;
    }
    
void main(){
    insert(100);
    insert(110);
    insert(120);
    insert(90);
    insert(105);
    insert(95);
    insert(94);
    insert(80);
    delete(100);
    printf(" Min is : %d",getMin());
    printf("PreOrder : ");
    preorder(root);
    printf("Inorder : ");
    inOrder(root);
    printf("PostOrder : ");
    postOrder(root);
}
               
                      
</pre>
                </div>
                <div class="output">
                  <h1>OUTPUT</h1>
                  <pre>
 Min is : 80
 PreOrder : 105 90 80 95 94 110 120  
 Inorder : 80 90 94 95 105 110 120   
 PostOrder : 80 94 95 90 120 110 105 
                  </pre>
                </div>
              </div>
              <div class="question">
                <div class="solve">
                  <h2>Ques 9. FIND INORDER PREDECESSOR AND INORDER SUCCESSOR OF BINARY SEARCH TREE (DYNAMICALLY
                    REPRESENTED)</h2>
                  <pre>
       #include < stdio.h>
         #include < stdlib.h>
       
             int data;
             struct Tree *left;
             struct Tree *right;
         };
         struct Tree *root = NULL,*newNode,*search,*prevSearch;
         struct Tree* findInSucessor(struct Tree *node){
             if(node == NULL){
                 return node;
             }
             node = node->right;
             while(node->left != NULL){
                 node = node->left;
             }
             return node;
         }
         struct Tree* findPrecedessor(struct Tree *node){
             if(node == NULL){
                 return node;
             }
             node = node->left;
             while(node->right != NULL){
                 node = node->right;
             }
             return node;
         }
         void main(){
         insert(100);
         insert(110);
         insert(120);
         insert(105);
         insert(85);
         insert(70);
         insert(80);
         printf("INORDER SUCCESSOR is : %d ",(findInSucessor(root)->data));
         printf("PREDECESSOR  is : %d",(findPrecedessor(root)->data));
         }
       
       
   </pre>
                </div>
                <div class="output">
                  <h1>OUTPUT</h1>
                  <pre>
   INORDER SUCCESSOR is : 105
   PREDECESSOR  is : 85
     </pre>
                </div>
              </div>
              <div class="question">
                <div class="solve">
                  <h2>Ques 10.FIND KTH Largest ELEMENT IN A BINARY SEARCH TREE THROUGH ARRAY</h2>
                  <pre>
        #include < stdio.h>
          #define MAX 30
      
          int tree[MAX];
          int size = 0;
      
          int track = 0;
          int findKthLargest(int index,int k){
              if(index >= MAX || index < 0 || tree[index] == -1){
                return -1;
             }
             int leftIndx = 2*index + 1;
             int rightIndx = 2*index + 2;
             int left = findKthLargest(leftIndx,k);
              if(left != -1){
                return left;
              }
             track++;
             if(track == size-k+1){
                return tree[index];
             }
             return findKthLargest(rightIndx,k);
            }
            
            
          void main(){
            for(int i = 0;i < MAX;i++){
              tree[i] = -1;
            }
           insert(100);
           insert(80);
           insert(110);
           insert(70);
           insert(85);
           insert(105);
           insert(120);
         
            printf("\nInorder : ");
            inOrder(0);
            printf("\n%d largest elem is : %d",3,findKthLargest(0,3));
        
           
          }
        
        
    </pre>
                </div>
                <div class="output">
                  <h1>OUTPUT</h1>
                  <pre>

Inorder : 70 80 85 100 105 110 120 
3 largest elem is : 105
        </pre>
                </div>
              </div>
              <div class="question">
                <div class="solve">
                  <h2>Ques 11. FIND KTH SMALLEST ELEMENT IN A BINARY SEARCH TREE THROUGH ARRAY</h2>
                  <pre>
          #include < stdio.h>
            #define MAX 30
        
            int tree[MAX];
            int size = 0;
            
            int track = 0;
            int findKthSmall(int index,int k){
              if(index >= MAX || index < 0 || tree[index] == -1){
                return -1;
             }
             int leftIndx = 2*index + 1;
             int rightIndx = 2*index + 2;
             int left = findKthSmall(leftIndx,k);
              if(left != -1){
                return left;
              }
             track++;
             if(track == k){
                return tree[index];
             }
             return findKthSmall(rightIndx,k);
            }
            
            void main(){
              for(int i = 0;i < MAX;i++){
                tree[i] = -1;
              }
             insert(100);
             insert(80);
             insert(110);
             insert(70);
             insert(85);
             insert(105);
             insert(120);
           
              printf("\nInorder : ");
              inOrder(0);
              printf("\n%d smallest elem is : %d",3,findKthSmall(0,3));
          
             
            }
          
      </pre>
                </div>
                <div class="output">
                  <h1>OUTPUT</h1>
                  <pre>
Inorder : 70 80 85 100 105 110 120 
3 smallest elem is : 85
        </pre>
                </div>
              </div>
              <div class="question">
                <div class="solve">
                  <h2>Ques 12.CONSTRUCT BINARY SEARCH TREE FROM GIVEN PREORDER TRAVERSAL THROUGH ARRAYS
                    Binarytree.C</h2>
                  <pre>
   #include < stdio.h>
       int tree[MAX];
       int size = 0;
       void buildBST(int pre[],int n){
         for(int i = 0; i < n;i++){
           insert(pre[i]);
       }
     }
       void preOrder(int index){
        if(index >= MAX || index < 0){
           return;
      }
        printf("%d ",tree[index]);
        int leftIndx = 2*index + 1;
        int rightIndx = 2*index + 2;
        if(tree[leftIndx] != -1) preOrder(leftIndx);
        if(tree[rightIndx] != -1) preOrder(rightIndx);
     }
       void main(){
         for(int i = 0;i < MAX;i++){
           tree[i] = -1;
       }
       
         int pre[] = {100,80,70,85,110,105,120};
         int n = sizeof(pre)/sizeof(int);
         buildBST(pre,n);
         printf("\nPreOrder : ");
         preOrder(0);
       
     }
         
   </pre>
                </div>
                <div class="output">
                  <h1>OUTPUT</h1>
                  <pre>
PreOrder : 100 80 70 85 110 105 120
                </pre>
                </div>
              </div>
              <div class="question">
                <div class="solve">
                  <h2>Ques 14. CHECK WHETHER BINARY SEARCH TREE CONTAINS DEAD END</h2>
                  <pre>

      #include < stdio.h>
          #define MAX 30
      
          int containsDeadEnd(struct Tree* root){
              if(root == NULL){
                  return 0;
              }
              if(root->left == NULL && root->right == NULL){
                  if(searchFunc(root->data - 1) == 1 && searchFunc(root->data + 1) == 1){
                      return 1;
                  }
              }
             return containsDeadEnd(root->left) ||  containsDeadEnd(root->right);
          }
          
          void main(){
              insert(8);
              insert(7);
              insert(10);
              insert(2);
              insert(9);
              insert(13);
              inOrder(root);
             
              if(containsDeadEnd(root)){
                  printf("\n yes dead end exist");
              }else {
                  printf("\n Dead end does not exists.");
              }
          }    
                </pre>
                </div>
                <div class="output">
                  <h1>OUTPUT</h1>
                  <pre>
     2 7 8 9 10 13     
     yes dead end exist
                  </pre>
                </div>
              </div>
              <div class="question">
                <div class="solve">
                  <h2>Ques 13.COUNT THE NUMBER OF NODES IN BINARY SEARCH TREE CONSTRUCTED DYNAMICALLY</h2>
                  <pre>


              #include < stdio.h>
              int countNodes(struct Tree *root){
                   if(root == NULL) return 0;
                   int leftCount = countNodes(root->left);
                   int rightCount = countNodes(root->right);
                   return leftCount+rightCount+1;
             }

              void main(){
                   insert(100);
                   insert(80);
                   insert(110);
                   insert(85);
                   insert(70);
                   insert(105);
                   insert(120);
                   printf("\n Preorder of BST : ");
                  preorder(root);
                  printf("\n Total no. of nodes in BST : %d",countNodes(root));

             }  
                </pre>
                </div>
                <div class="output">
                  <h1>OUTPUT</h1>
                  <pre>

          Preorder of BST : 100 80 70 85 110 105 120 
          Total no. of nodes in BST : 7
                  </pre>
                </div>
              </div>
              <div class="question">
                <div class="solve">
                  <h2>Ques 14.CONSTRUCT BINARY SEARCH TREE FROM GIVEN PostOrder TRAVERSAL THROUGH ARRAYS.</h2>
                  <pre>

                    #include < stdio.h>
          int tree[MAX];
          int size = 0;
          void insert(int val){
               if(size == MAX){
                   printf("Tree is Full!");
                  return;
             }
              // add root value.
              if(size == 0){
                   tree[0] = val;
                   size++;
                   return;
            }
             int i = 0;
             // getting correct index.
             while(i < MAX && tree[i] != -1){
               if(val < tree[i]){
                   i = 2*i + 1;
             }else if(val > tree[i]){
                   i = 2*i + 2;
             }else {
                   printf("Duplicate is not allowed!");
                  break;
             }
           }
            if(i < MAX){
               tree[i] = val;
               size++;
           }else {
               printf("Tree is Full!");
              return;
           }
         }
          void preOrder(int index){
            if(index >= MAX || index < 0){
               return;
          }
           printf("%d ",tree[index]);
           int leftIndx = 2*index + 1;
           int rightIndx = 2*index + 2;
           if(tree[leftIndx] != -1) preOrder(leftIndx);
           if(tree[rightIndx] != -1) preOrder(rightIndx);
         }

          void buildBST(int arr[],int n){
             for(int i = n-1; i >= 0 ;i--){
               insert(arr[i]);
           }
         }

          void main(){
             for(int i = 0;i < MAX;i++){
               tree[i] = -1;
           }

            int post[] = {70,85,80,105,120,110,100};
            int n = sizeof(post)/sizeof(int);
            buildBST(post,n);
            buildBST(pre,n);
            printf("\n PreOrder : ");
            preOrder(0);
            printf("\n PostOrder : ");
            postOrder(0);
         }


        </pre>
                </div>
                <div class="output">
                  <h1>OUTPUT</h1>
                  <pre>


  PreOrder : 
  
  100 80 70 85 110 105 120  
            
  PostOrder : 
  
  70 85 80 105 120 110 100  
                  </pre>
                </div>
              </div>
              <div class="question">
                <div class="solve">
                  <h2>Ques 15. CREATE ALMOST COMPLETE BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY)</h2>
                  <pre>

     #include < stdio.h>
       struct TNode* findNode(){
               add(root);
               add(NULL);
               while(!isQEmpty()){
                   struct TNode *cur = remove1();
                   if(cur == NULL){
                       if(isQEmpty() == 1) break;
                       else {
                           add(NULL);
                       }
                   }else {
                       if(cur->left == NULL || cur->right){
                           return cur;
                       }
                       if(cur->left != NULL) add(cur->left);
                       if(cur->right != NULL) add(cur->right);
                   }
               }
               return NULL;
           }
           void insertAtNode(struct TNode *par,int val){
               struct TNode *nn = (struct TNode*)malloc(sizeof(struct TNode));
               if(par != NULL){
                   nn->data = val;
                   if(par->left == NULL){
                       par->left = nn;
                   }else {
                       par->right = nn;
                   }
                   nn->left = NULL;
                   nn->right = NULL;
               }else {
                   printf("
       Parent val does not exist!");
               }
           }
           void inOrder(struct TNode *node){
               if(node == NULL){
                   return;
               }
               inOrder(node->left);
               printf("%d ",node->data);
               inOrder(node->right);
           }
           int isQEmpty(){
               if(Qsize == 0) return 1;
               return 0;
           }
           void levelOrder(struct TNode *root){
               add(root);
               add(NULL);
               while(!isQEmpty()){
                   struct TNode *cur = remove1();
                   if(cur == NULL){
                       if(isQEmpty() == 1) break;
                       else {
                           add(NULL);
                       }
                   }else {
                       printf("%d ",cur->data);
                       if(cur->left != NULL) add(cur->left);
                       if(cur->right != NULL) add(cur->right);
                   }
               }
           
           }
           void buildAlmostBinaryTree(){
               int val,choice;
               printf("Enter a root node : ");
               scanf("%d",&val);
               if(root == NULL){
                   root = (struct TNode*)malloc(sizeof(struct TNode));
                   root->data = val;
                   root->left = NULL;
                   root->right = NULL;
               }
               while(1){
                   printf("\n 1.Insert\n 2.Exit\n ");
                   scanf("%d",&choice);
                   if(choice == 1){
                   struct TNode *par = findNode();
                   printf("\n Enter value : ");
                   scanf("%d",&val);
                   insertAtNode(par,val);
                   }else if(choice == 2){
                       break;
                   }else {
                       printf("\n Invalid choice!");
                   }
               }
                printf("\n Level order of Tree : ");
                levelOrder(root);
           }
           void main(){
               buildAlmostBinaryTree();
           }
     
 </pre>
                </div>
                <div class="output">
                  <h1>OUTPUT</h1>
                  <pre>

              Enter a root node : 1

               1.Insert
               2.Exit  
               1
               
               Enter value : 2
               
               1.Insert
               2.Exit  
               1
               
               Enter value : 3
               
               1.Insert
               2.Exit  
               1
               
               Enter value : 4
               
               1.Insert
               2.Exit  
               1
               
               Enter value : 5
               
               1.Insert
               2.Exit  
               1
               
               Enter value : 6
               
               1.Insert
               2.Exit
               2
               
               Level order of Tree : 
               1 2 3 4 5 6               
                  </pre>
                </div>
              </div>
              <div class="question">
                <div class="solve">
                  <h2>Ques 16. CREATE STRICTLY BINARY TREE FROM THE GIVEN INPUT BY THE USER (DYNAMICALLY)</h2>
                  <pre>

     #include < stdio.h>
       struct Tree* getNode(struct Tree* root,int val){
           if(root == NULL) return NULL;
           if(root->data == val) return root;
           struct Tree *left = getNode(root->left,val);
           if(left != NULL){
               return left;
           }
           return getNode(root->right,val);
       }
       void insertAtNode(struct Tree *par,int val){
           struct Tree *nn = (struct Tree*)malloc(sizeof(struct Tree));
           if(par != NULL){
               nn->data = val;
               if(par->left == NULL){
                   par->left = nn;
               }else {
                   par->right = nn;
               }
               nn->left = NULL;
               nn->right = NULL;
           }else {
               printf("
   Parent val does not exist!");
           }
       }
       
       void buildStrictlyBinaryTree(){
           int val1,val2,parValue,choice;
           printf("Enter a root node : ");
           scanf("%d",&parValue);
           insert(parValue);
           while(1){
               printf("\n 1.Insert\n 2.Exit\n ");
               scanf("%d",&choice);
               if(choice == 1){
               printf("\n PreOrder of Tree : ");
               preorder(root);
               printf("\n Where you want to insert : ");
               scanf("%d",&parValue);
               struct Tree *par = getNode(root,parValue);
               if(par == NULL){
                   printf("\n Parent val does not exist!");
                   continue;
               }
               printf("\n Enter value of left child : ");
               scanf("%d",&val1);
               printf("\n Enter value of right child : ");
               scanf("%d",&val2);
               insertAtNode(par,val1);
               insertAtNode(par,val2);
               }else if(choice == 2){
                   break;
               }else {
                   printf("\n Invalid choice!");
               }
           }
            printf("\n Inorder of Tree : ");
            inOrder(root);
       }
       
       void main(){
          
           buildStrictlyBinaryTree();
       }
     
 </pre>
                </div>
                <div class="output">
                  <h1>OUTPUT</h1>
                  <pre>

        Enter a root node : 100

        1.Insert
        2.Exit  
        1
                    
         PreOrder of Tree : 100     
         Where you want to insert : 
         100
                    
        Enter value of left child : 
        80
                    
        Enter value of right child : 
        110
                    
        1.Insert
        2.Exit  
        1
        
        PreOrder of Tree :
         100 80 110 

        Where you want to insert : 
        80 
        
        Enter value of left child :
         70
                    
        Enter value of right child :
         85
                    
        1.Insert
        2.Exit  
        1
                    
        PreOrder of Tree :
         100 80 70 85 110 
        Where you want to insert :
         110
                    
        Enter value of left child :
         105
                    
        Enter value of right child :
         120
                    
         1.Insert
         2.Exit
         2
                    
        Inorder of Tree : 
        70 80 85 100 105 110 120
                  </pre>
                </div>
              </div>
              <footer>
                <p>&copy;2023 developed by <a href="#">Faham Naz</a> </p>
              </footer>

</body>

</html>